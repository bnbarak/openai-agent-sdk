{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A modern Java SDK for building AI agents with OpenAI's API, similar to the TypeScript OpenAI Agents SDK , following its public API and implementation patterns where possible. Built on the OpenAI Java SDK . Features Agents : Build conversational AI agents with OpenAI models Tool Calling : Define custom tools that agents can invoke Multi-Agent Handoffs : Transfer conversations between specialized agents Memory Management : Built-in session management with multiple backends Distributed Tracing : OpenTelemetry-compatible tracing with OpenAI platform integration Guardrails : Input/output validation and safety controls Streaming : Real-time streaming of agent responses Example <dependency> <groupId> ai.acolite </groupId> <artifactId> openai-agent-sdk </artifactId> <version> 0.4.0 </version> </dependency> implementation 'ai.acolite:openai-agent-sdk:0.4.0' import ai.acolite.agentsdk.core.Agent ; import ai.acolite.agentsdk.core.RunResult ; import ai.acolite.agentsdk.core.Runner ; import ai.acolite.agentsdk.core.types.TextOutput ; import ai.acolite.agentsdk.core.types.UnknownContext ; public class Example { public static void main ( String [] args ) { Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Write a haiku about recursion in programming.\" ); System . out . println ( result . getFinalOutput ()); } } Getting Started New to the SDK? Start with the Quickstart guide to build your first agent. Guides Learn how to use specific features: Agents - Creating and configuring agents Tools - Defining custom tools Handoffs - Multi-agent workflows Sessions - Memory and conversation history Tracing - Observability and debugging Requirements Java 21 or higher Maven 3.6+ or Gradle 7+ OpenAI API key ( Get one here ) Installation Add to your pom.xml : <dependency> <groupId> ai.acolite </groupId> <artifactId> openai-agent-sdk </artifactId> <version> 0.4.0 </version> </dependency> Support GitHub Issues API Reference Email: support@acolite.ai","title":"Home"},{"location":"#features","text":"Agents : Build conversational AI agents with OpenAI models Tool Calling : Define custom tools that agents can invoke Multi-Agent Handoffs : Transfer conversations between specialized agents Memory Management : Built-in session management with multiple backends Distributed Tracing : OpenTelemetry-compatible tracing with OpenAI platform integration Guardrails : Input/output validation and safety controls Streaming : Real-time streaming of agent responses","title":"Features"},{"location":"#example","text":"<dependency> <groupId> ai.acolite </groupId> <artifactId> openai-agent-sdk </artifactId> <version> 0.4.0 </version> </dependency> implementation 'ai.acolite:openai-agent-sdk:0.4.0' import ai.acolite.agentsdk.core.Agent ; import ai.acolite.agentsdk.core.RunResult ; import ai.acolite.agentsdk.core.Runner ; import ai.acolite.agentsdk.core.types.TextOutput ; import ai.acolite.agentsdk.core.types.UnknownContext ; public class Example { public static void main ( String [] args ) { Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Write a haiku about recursion in programming.\" ); System . out . println ( result . getFinalOutput ()); } }","title":"Example"},{"location":"#getting-started","text":"New to the SDK? Start with the Quickstart guide to build your first agent.","title":"Getting Started"},{"location":"#guides","text":"Learn how to use specific features: Agents - Creating and configuring agents Tools - Defining custom tools Handoffs - Multi-agent workflows Sessions - Memory and conversation history Tracing - Observability and debugging","title":"Guides"},{"location":"#requirements","text":"Java 21 or higher Maven 3.6+ or Gradle 7+ OpenAI API key ( Get one here )","title":"Requirements"},{"location":"#installation","text":"Add to your pom.xml : <dependency> <groupId> ai.acolite </groupId> <artifactId> openai-agent-sdk </artifactId> <version> 0.4.0 </version> </dependency>","title":"Installation"},{"location":"#support","text":"GitHub Issues API Reference Email: support@acolite.ai","title":"Support"},{"location":"CONTRIBUTING_DOCS/","text":"This guide explains how to write and update documentation in the docs/ directory. Table of Contents Philosophy Documentation Structure Writing Style Including Code Examples Linking to API Documentation File Naming Conventions MkDocs Syntax Testing Documentation AI-Generated Documentation Philosophy One Source of Truth Never copy-paste code into documentation. Instead: Write real, runnable Java examples in src/main/java/ai/acolite/agentsdk/examples/ Test them in CI (they run in E2E workflow) Reference them in docs via links or includes Why? Code examples can go stale. If they're real files that compile and run, they can't lie. Docs People Actually Read Write documentation like you're explaining to a colleague, not writing a textbook: Start with the outcome : \"By the end of this guide, you'll have a working agent.\" Show, don't tell : Code example first, explanation second Keep it scannable : Use headings, bullets, code blocks No fluff : Get to the point Documentation Structure Our documentation structure is inspired by the OpenAI Agents TypeScript SDK but adapted for Java: docs / \u251c\u2500\u2500 CONTRIBUTING_DOCS . md # This file (guideline for contributors) \u251c\u2500\u2500 quickstart . md # First stop for new users - get started in 5 minutes \u251c\u2500\u2500 guides / # Core guides (task-oriented, with inline examples) \u2502 \u251c\u2500\u2500 agents . md # Creating and configuring agents \u2502 \u251c\u2500\u2500 running - agents . md # How to run agents and handle results \u2502 \u251c\u2500\u2500 tools . md # Defining custom tools with FunctionTool \u2502 \u251c\u2500\u2500 handoffs . md # Agent-to-agent handoffs \u2502 \u251c\u2500\u2500 sessions . md # Session management (MemorySession, SQLiteSession) \u2502 \u251c\u2500\u2500 models . md # Working with different OpenAI models \u2502 \u251c\u2500\u2500 guardrails . md # Input/output validation and safety \u2502 \u251c\u2500\u2500 streaming . md # Streaming responses \u2502 \u251c\u2500\u2500 tracing . md # Distributed tracing and observability \u2502 \u2514\u2500\u2500 troubleshooting . md # Common issues and solutions \u251c\u2500\u2500 examples / # Real-world examples (outcome-oriented) \u2514\u2500\u2500 api - reference / # Javadoc-generated API docs \u2514\u2500\u2500 ( auto - generated ) When to Create a New Doc Guide : Task-oriented, \"How do I X?\" - Always include inline code examples Example : Outcome-oriented, \"Build a customer service bot\" - Show complete working code Reference : Information-oriented, \"What are all the config options?\" - Link to Javadoc Writing Style Tone Conversational but professional : \"Let's build an agent\" not \"The instantiation of an agent object shall...\" Active voice : \"Create an agent\" not \"An agent is created\" Present tense : \"The agent calls tools\" not \"The agent will call tools\" Direct : Use \"you\" and \"we\" Structure Every guide should have: # Guide Title Brief 1-2 sentence overview of what this guide covers. ## Prerequisites - List required knowledge - Link to other docs if needed ## Quick Example ```java Link to complete example Concepts Now explain what's happening... Common Patterns Show 2-3 common use cases... Troubleshooting Common errors and how to fix them... Next Steps Link to related guides Link to examples ### Formatting - ** Code **: Always use syntax - highlighted code blocks with language - ** Commands **: Use `bash` code blocks for shell commands - ** File paths **: Use `code` formatting : `src/main/java/Agent.java` - ** Emphasis **: Use ** bold ** for important terms , _italic_ sparingly --- ## Including Code Examples ** We love inline examples !** Every guide should show code directly in the page , not just link to files . ### Preferred: Snippet Regions (Inline + One Source of Truth) This is the ** best approach ** - it shows code inline while keeping examples testable and current . Mark regions in your example files : ** In `BasicTextOutputExample.java` :** ` `` java public class BasicTextOutputExample { public static void main(String[] args) { // region create-agent // Create a simple agent Agent<UnknownContext, TextOutput> agent = Agent.<UnknownContext, TextOutput>builder() .name(\"Assistant\") .instructions(\"You are a helpful assistant. Keep responses concise and clear.\") .build(); // endregion create-agent } } In docs: ## Creating an Agent Here's how to create a basic agent: ```java View complete example ** Why this is best : ** - Code appears inline in the guide ( readers don 't have to click away) - Code is real , tested , and runs in CI - Updates to examples automatically appear in docs - Readers can still click to see the complete file ### Alternative: Include Entire File (Use for Small Examples Only) For very small examples ( < 30 lines ), include the entire file : ``` markdown ## Example: Creating an Agent ``` java package ai . acolite . agentsdk . examples ; import ai.acolite.agentsdk.core.Agent ; import ai.acolite.agentsdk.core.RunResult ; import ai.acolite.agentsdk.core.Runner ; import ai.acolite.agentsdk.core.types.TextOutput ; import ai.acolite.agentsdk.core.types.UnknownContext ; /** * BasicTextOutputExample * * < p > Simplest example demonstrating text - based agent interactions . * * < p > This example shows : - Creating a basic agent with instructions - Running the agent with a text * prompt - Accessing the text response and usage statistics * * < p > Usage : OPENAI_API_KEY = sk -... java ai . acolite . agentsdk . examples . BasicTextOutputExample */ public class BasicTextOutputExample { public static void main ( String [] args ) { String apiKey = System . getenv ( \"OPENAI_API_KEY\" ); if ( apiKey == null || apiKey . isEmpty ()) { System . err . println ( \"Error: OPENAI_API_KEY environment variable not set\" ); System . err . println ( \"Usage: OPENAI_API_KEY=sk-... java ai.acolite.agentsdk.examples.BasicTextOutputExample\" ); System . exit ( 1 ); } System . out . println ( \"=== Basic Text Output Example === \\n \" ); // region create - agent // Create a simple agent Agent < UnknownContext , TextOutput > agent = Agent .< UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant. Keep responses concise and clear.\" ) . build (); // endregion create - agent // region run - agent // Run the agent with a simple question RunResult < UnknownContext , ? > result = Runner . run ( agent , \"Explain what an AI agent is in one sentence.\" ); // endregion run - agent // Display the response System . out . println ( \"Question:\" ); System . out . println ( \"Explain what an AI agent is in one sentence.\" ); System . out . println (); System . out . println ( \"Agent response:\" ); System . out . println ( result . getFinalOutput ()); System . out . println (); // region check - usage // Display usage statistics System . out . println ( \"Usage statistics:\" ); System . out . println ( \" Total tokens: \" + result . getUsage () . getTotalTokens ()); System . out . println ( \" Input tokens: \" + result . getUsage () . getInputTokens ()); System . out . println ( \" Output tokens: \" + result . getUsage () . getOutputTokens ()); // endregion check - usage } } **Warning**: Only use for small files. Large files make docs hard to scan. ## # Last Resort: Link Only (Use Rarely) Only link without showing code if the example is extremely long or complex: ```markdown ## Example: Creating an Agent See [HelloWorld.java](https://github.com/bnbarak/openai-agent-sdk/blob/main/src/main/java/ai/acolite/agentsdk/examples/HelloWorld.java) for a complete working example. When to use : Advanced examples, complete applications, or reference implementations. What NOT to Do \u274c Don't write example code directly in markdown: <!-- BAD: This code will go stale --> ```java Agent agent = new Agent(...); // This might not even compile! \u2705 ** Do link to real , tested code :** ``` markdown <!-- GOOD : Links to code that compiles and runs --> See [ complete example ]( https : //github.com/.../HelloWorld.java) Linking to API Documentation Link to Javadoc Point users to Javadoc for detailed API reference: For details on all available options, see the [ `Agent.Builder` ](/api/ai/acolite/agentsdk/core/Agent.Builder.html) Javadoc. Link Between Docs Use relative links: See the [ Tools Guide ]( guides/tools.md ) for more information on custom tools. External Links Always use full URLs: Learn more about [ OpenAI's Responses API ]( https://platform.openai.com/docs/api-reference/responses ). File Naming Conventions Use kebab-case : multi-agent-handoffs.md not MultiAgentHandoffs.md Be descriptive : memory-session-management.md not memory.md Avoid redundancy : tools.md not tools-guide.md (it's already in guides/ ) MkDocs Syntax Headers # Top Level (Page Title) - Only one per page ## Section ### Subsection #### Rarely needed Code Blocks Always specify language for syntax highlighting: ```java // Java code Agent agent = Agent . builder (). build (); ``` ```bash # Shell commands mvn clean install ``` ```xml <!-- XML/Maven --> <dependency> <groupId> ai.acolite </groupId> <artifactId> openai-agent-sdk </artifactId> </dependency> ``` Admonitions (Callout Boxes) Use for warnings, tips, notes: !!! note This is a note. Use for additional context. !!! tip This is a tip. Use for helpful suggestions. !!! warning This is a warning. Use for important caveats. !!! danger This is danger. Use for critical security warnings. Tables | Feature | Description | |---------|-------------| | Tools | Custom functions agents can call | | Handoffs| Transfer between agents | Lists - Unordered list - Another item - Nested item 1. Ordered list 2. Another item Testing Documentation Before Committing Check links : All links to code must point to real files Verify examples : All referenced examples must exist and work Test build : Run mkdocs build locally Preview : Run mkdocs serve and view at http://localhost:8000 Commands # Install MkDocs pip install mkdocs mkdocs-material mkdocs-include-markdown-plugin # Preview locally mkdocs serve # Build static site mkdocs build # Validate links (if link checker installed) mkdocs build --strict CI Checks Documentation is automatically checked in CI: - All code examples are executed in E2E workflow - Broken links fail the build (once configured) - MkDocs build errors fail the build AI-Generated Documentation Policy AI-generated documentation must be reviewed by a human before merging. From the launch plan (Stage 1.2): AI generated docs must be reviewed before merge If You Use AI to Draft Docs \u2705 Do : Use AI to draft initial structure \u2705 Do : Use AI to improve clarity \u2705 Do : Have a human review and edit \u274c Don't : Merge AI-generated docs without review \u274c Don't : Let AI write code examples (write real code instead) Why? AI can hallucinate APIs that don't exist or generate outdated code. Always verify: - Code examples compile - APIs actually exist - Links point to real files Examples Good Example # Creating Your First Agent This guide shows you how to create a basic agent and run your first conversation. ## Prerequisites - Java 21+ - OpenAI API key set in environment: `OPENAI_API_KEY` ## Quick Start ```java View complete example Running the Agent Once you have an agent, run it with a message: How It Works The Agent.builder() creates a new agent with: - model : The OpenAI model to use (gpt-4.1, gpt-4.1-mini, etc.) - instructions : The system prompt that defines agent behavior When you call agent.run() , the agent: 1. Sends your message to OpenAI 2. Receives the response 3. Returns a RunResult with the output Next Steps Add tools to your agent Enable conversation memory ** Why this is good : ** - Shows real , tested code inline ( pulled from BasicTextOutputExample . java ) - Links to complete example for context - Multiple code snippets with region markers - Clear explanations after each code block - No copy - pasted code that could go stale ### Bad Example ``` markdown # Agent Documentation The Agent class is the main class for creating agents in the OpenAI Agent SDK for Java . ## Constructor The Agent class has a constructor that takes parameters . ## Methods ### run The run method runs the agent . ``` java // This code might not work agent . run (); See Also Other documentation ``` Problems : - No clear outcome - No working example - Code snippet not tested - Vague descriptions - No links to real code Quick Checklist Before submitting documentation: [ ] Links point to real files (not fictional paths) [ ] Code examples are in src/main/java/.../examples/ and tested [ ] Writing is clear and concise [ ] Tested with mkdocs serve locally [ ] No copy-pasted code (only links or includes) [ ] Follows file naming conventions [ ] Reviewed by a human (if AI-assisted) Questions? Check existing docs in docs/ for examples Open a GitHub issue with the documentation label Ask in pull request reviews Last Updated : January 2026","title":"CONTRIBUTING DOCS"},{"location":"CONTRIBUTING_DOCS/#table-of-contents","text":"Philosophy Documentation Structure Writing Style Including Code Examples Linking to API Documentation File Naming Conventions MkDocs Syntax Testing Documentation AI-Generated Documentation","title":"Table of Contents"},{"location":"CONTRIBUTING_DOCS/#philosophy","text":"","title":"Philosophy"},{"location":"CONTRIBUTING_DOCS/#one-source-of-truth","text":"Never copy-paste code into documentation. Instead: Write real, runnable Java examples in src/main/java/ai/acolite/agentsdk/examples/ Test them in CI (they run in E2E workflow) Reference them in docs via links or includes Why? Code examples can go stale. If they're real files that compile and run, they can't lie.","title":"One Source of Truth"},{"location":"CONTRIBUTING_DOCS/#docs-people-actually-read","text":"Write documentation like you're explaining to a colleague, not writing a textbook: Start with the outcome : \"By the end of this guide, you'll have a working agent.\" Show, don't tell : Code example first, explanation second Keep it scannable : Use headings, bullets, code blocks No fluff : Get to the point","title":"Docs People Actually Read"},{"location":"CONTRIBUTING_DOCS/#documentation-structure","text":"Our documentation structure is inspired by the OpenAI Agents TypeScript SDK but adapted for Java: docs / \u251c\u2500\u2500 CONTRIBUTING_DOCS . md # This file (guideline for contributors) \u251c\u2500\u2500 quickstart . md # First stop for new users - get started in 5 minutes \u251c\u2500\u2500 guides / # Core guides (task-oriented, with inline examples) \u2502 \u251c\u2500\u2500 agents . md # Creating and configuring agents \u2502 \u251c\u2500\u2500 running - agents . md # How to run agents and handle results \u2502 \u251c\u2500\u2500 tools . md # Defining custom tools with FunctionTool \u2502 \u251c\u2500\u2500 handoffs . md # Agent-to-agent handoffs \u2502 \u251c\u2500\u2500 sessions . md # Session management (MemorySession, SQLiteSession) \u2502 \u251c\u2500\u2500 models . md # Working with different OpenAI models \u2502 \u251c\u2500\u2500 guardrails . md # Input/output validation and safety \u2502 \u251c\u2500\u2500 streaming . md # Streaming responses \u2502 \u251c\u2500\u2500 tracing . md # Distributed tracing and observability \u2502 \u2514\u2500\u2500 troubleshooting . md # Common issues and solutions \u251c\u2500\u2500 examples / # Real-world examples (outcome-oriented) \u2514\u2500\u2500 api - reference / # Javadoc-generated API docs \u2514\u2500\u2500 ( auto - generated )","title":"Documentation Structure"},{"location":"CONTRIBUTING_DOCS/#when-to-create-a-new-doc","text":"Guide : Task-oriented, \"How do I X?\" - Always include inline code examples Example : Outcome-oriented, \"Build a customer service bot\" - Show complete working code Reference : Information-oriented, \"What are all the config options?\" - Link to Javadoc","title":"When to Create a New Doc"},{"location":"CONTRIBUTING_DOCS/#writing-style","text":"","title":"Writing Style"},{"location":"CONTRIBUTING_DOCS/#tone","text":"Conversational but professional : \"Let's build an agent\" not \"The instantiation of an agent object shall...\" Active voice : \"Create an agent\" not \"An agent is created\" Present tense : \"The agent calls tools\" not \"The agent will call tools\" Direct : Use \"you\" and \"we\"","title":"Tone"},{"location":"CONTRIBUTING_DOCS/#structure","text":"Every guide should have: # Guide Title Brief 1-2 sentence overview of what this guide covers. ## Prerequisites - List required knowledge - Link to other docs if needed ## Quick Example ```java Link to complete example","title":"Structure"},{"location":"CONTRIBUTING_DOCS/#concepts","text":"Now explain what's happening...","title":"Concepts"},{"location":"CONTRIBUTING_DOCS/#common-patterns","text":"Show 2-3 common use cases...","title":"Common Patterns"},{"location":"CONTRIBUTING_DOCS/#troubleshooting","text":"Common errors and how to fix them...","title":"Troubleshooting"},{"location":"CONTRIBUTING_DOCS/#next-steps","text":"Link to related guides Link to examples ### Formatting - ** Code **: Always use syntax - highlighted code blocks with language - ** Commands **: Use `bash` code blocks for shell commands - ** File paths **: Use `code` formatting : `src/main/java/Agent.java` - ** Emphasis **: Use ** bold ** for important terms , _italic_ sparingly --- ## Including Code Examples ** We love inline examples !** Every guide should show code directly in the page , not just link to files . ### Preferred: Snippet Regions (Inline + One Source of Truth) This is the ** best approach ** - it shows code inline while keeping examples testable and current . Mark regions in your example files : ** In `BasicTextOutputExample.java` :** ` `` java public class BasicTextOutputExample { public static void main(String[] args) { // region create-agent // Create a simple agent Agent<UnknownContext, TextOutput> agent = Agent.<UnknownContext, TextOutput>builder() .name(\"Assistant\") .instructions(\"You are a helpful assistant. Keep responses concise and clear.\") .build(); // endregion create-agent } } In docs: ## Creating an Agent Here's how to create a basic agent: ```java View complete example ** Why this is best : ** - Code appears inline in the guide ( readers don 't have to click away) - Code is real , tested , and runs in CI - Updates to examples automatically appear in docs - Readers can still click to see the complete file ### Alternative: Include Entire File (Use for Small Examples Only) For very small examples ( < 30 lines ), include the entire file : ``` markdown ## Example: Creating an Agent ``` java package ai . acolite . agentsdk . examples ; import ai.acolite.agentsdk.core.Agent ; import ai.acolite.agentsdk.core.RunResult ; import ai.acolite.agentsdk.core.Runner ; import ai.acolite.agentsdk.core.types.TextOutput ; import ai.acolite.agentsdk.core.types.UnknownContext ; /** * BasicTextOutputExample * * < p > Simplest example demonstrating text - based agent interactions . * * < p > This example shows : - Creating a basic agent with instructions - Running the agent with a text * prompt - Accessing the text response and usage statistics * * < p > Usage : OPENAI_API_KEY = sk -... java ai . acolite . agentsdk . examples . BasicTextOutputExample */ public class BasicTextOutputExample { public static void main ( String [] args ) { String apiKey = System . getenv ( \"OPENAI_API_KEY\" ); if ( apiKey == null || apiKey . isEmpty ()) { System . err . println ( \"Error: OPENAI_API_KEY environment variable not set\" ); System . err . println ( \"Usage: OPENAI_API_KEY=sk-... java ai.acolite.agentsdk.examples.BasicTextOutputExample\" ); System . exit ( 1 ); } System . out . println ( \"=== Basic Text Output Example === \\n \" ); // region create - agent // Create a simple agent Agent < UnknownContext , TextOutput > agent = Agent .< UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant. Keep responses concise and clear.\" ) . build (); // endregion create - agent // region run - agent // Run the agent with a simple question RunResult < UnknownContext , ? > result = Runner . run ( agent , \"Explain what an AI agent is in one sentence.\" ); // endregion run - agent // Display the response System . out . println ( \"Question:\" ); System . out . println ( \"Explain what an AI agent is in one sentence.\" ); System . out . println (); System . out . println ( \"Agent response:\" ); System . out . println ( result . getFinalOutput ()); System . out . println (); // region check - usage // Display usage statistics System . out . println ( \"Usage statistics:\" ); System . out . println ( \" Total tokens: \" + result . getUsage () . getTotalTokens ()); System . out . println ( \" Input tokens: \" + result . getUsage () . getInputTokens ()); System . out . println ( \" Output tokens: \" + result . getUsage () . getOutputTokens ()); // endregion check - usage } } **Warning**: Only use for small files. Large files make docs hard to scan. ## # Last Resort: Link Only (Use Rarely) Only link without showing code if the example is extremely long or complex: ```markdown ## Example: Creating an Agent See [HelloWorld.java](https://github.com/bnbarak/openai-agent-sdk/blob/main/src/main/java/ai/acolite/agentsdk/examples/HelloWorld.java) for a complete working example. When to use : Advanced examples, complete applications, or reference implementations.","title":"Next Steps"},{"location":"CONTRIBUTING_DOCS/#what-not-to-do","text":"\u274c Don't write example code directly in markdown: <!-- BAD: This code will go stale --> ```java Agent agent = new Agent(...); // This might not even compile! \u2705 ** Do link to real , tested code :** ``` markdown <!-- GOOD : Links to code that compiles and runs --> See [ complete example ]( https : //github.com/.../HelloWorld.java)","title":"What NOT to Do"},{"location":"CONTRIBUTING_DOCS/#linking-to-api-documentation","text":"","title":"Linking to API Documentation"},{"location":"CONTRIBUTING_DOCS/#link-to-javadoc","text":"Point users to Javadoc for detailed API reference: For details on all available options, see the [ `Agent.Builder` ](/api/ai/acolite/agentsdk/core/Agent.Builder.html) Javadoc.","title":"Link to Javadoc"},{"location":"CONTRIBUTING_DOCS/#link-between-docs","text":"Use relative links: See the [ Tools Guide ]( guides/tools.md ) for more information on custom tools.","title":"Link Between Docs"},{"location":"CONTRIBUTING_DOCS/#external-links","text":"Always use full URLs: Learn more about [ OpenAI's Responses API ]( https://platform.openai.com/docs/api-reference/responses ).","title":"External Links"},{"location":"CONTRIBUTING_DOCS/#file-naming-conventions","text":"Use kebab-case : multi-agent-handoffs.md not MultiAgentHandoffs.md Be descriptive : memory-session-management.md not memory.md Avoid redundancy : tools.md not tools-guide.md (it's already in guides/ )","title":"File Naming Conventions"},{"location":"CONTRIBUTING_DOCS/#mkdocs-syntax","text":"","title":"MkDocs Syntax"},{"location":"CONTRIBUTING_DOCS/#headers","text":"# Top Level (Page Title) - Only one per page ## Section ### Subsection #### Rarely needed","title":"Headers"},{"location":"CONTRIBUTING_DOCS/#code-blocks","text":"Always specify language for syntax highlighting: ```java // Java code Agent agent = Agent . builder (). build (); ``` ```bash # Shell commands mvn clean install ``` ```xml <!-- XML/Maven --> <dependency> <groupId> ai.acolite </groupId> <artifactId> openai-agent-sdk </artifactId> </dependency> ```","title":"Code Blocks"},{"location":"CONTRIBUTING_DOCS/#admonitions-callout-boxes","text":"Use for warnings, tips, notes: !!! note This is a note. Use for additional context. !!! tip This is a tip. Use for helpful suggestions. !!! warning This is a warning. Use for important caveats. !!! danger This is danger. Use for critical security warnings.","title":"Admonitions (Callout Boxes)"},{"location":"CONTRIBUTING_DOCS/#tables","text":"| Feature | Description | |---------|-------------| | Tools | Custom functions agents can call | | Handoffs| Transfer between agents |","title":"Tables"},{"location":"CONTRIBUTING_DOCS/#lists","text":"- Unordered list - Another item - Nested item 1. Ordered list 2. Another item","title":"Lists"},{"location":"CONTRIBUTING_DOCS/#testing-documentation","text":"","title":"Testing Documentation"},{"location":"CONTRIBUTING_DOCS/#before-committing","text":"Check links : All links to code must point to real files Verify examples : All referenced examples must exist and work Test build : Run mkdocs build locally Preview : Run mkdocs serve and view at http://localhost:8000","title":"Before Committing"},{"location":"CONTRIBUTING_DOCS/#commands","text":"# Install MkDocs pip install mkdocs mkdocs-material mkdocs-include-markdown-plugin # Preview locally mkdocs serve # Build static site mkdocs build # Validate links (if link checker installed) mkdocs build --strict","title":"Commands"},{"location":"CONTRIBUTING_DOCS/#ci-checks","text":"Documentation is automatically checked in CI: - All code examples are executed in E2E workflow - Broken links fail the build (once configured) - MkDocs build errors fail the build","title":"CI Checks"},{"location":"CONTRIBUTING_DOCS/#ai-generated-documentation","text":"","title":"AI-Generated Documentation"},{"location":"CONTRIBUTING_DOCS/#policy","text":"AI-generated documentation must be reviewed by a human before merging. From the launch plan (Stage 1.2): AI generated docs must be reviewed before merge","title":"Policy"},{"location":"CONTRIBUTING_DOCS/#if-you-use-ai-to-draft-docs","text":"\u2705 Do : Use AI to draft initial structure \u2705 Do : Use AI to improve clarity \u2705 Do : Have a human review and edit \u274c Don't : Merge AI-generated docs without review \u274c Don't : Let AI write code examples (write real code instead)","title":"If You Use AI to Draft Docs"},{"location":"CONTRIBUTING_DOCS/#why","text":"AI can hallucinate APIs that don't exist or generate outdated code. Always verify: - Code examples compile - APIs actually exist - Links point to real files","title":"Why?"},{"location":"CONTRIBUTING_DOCS/#examples","text":"","title":"Examples"},{"location":"CONTRIBUTING_DOCS/#good-example","text":"# Creating Your First Agent This guide shows you how to create a basic agent and run your first conversation. ## Prerequisites - Java 21+ - OpenAI API key set in environment: `OPENAI_API_KEY` ## Quick Start ```java View complete example","title":"Good Example"},{"location":"CONTRIBUTING_DOCS/#running-the-agent","text":"Once you have an agent, run it with a message:","title":"Running the Agent"},{"location":"CONTRIBUTING_DOCS/#how-it-works","text":"The Agent.builder() creates a new agent with: - model : The OpenAI model to use (gpt-4.1, gpt-4.1-mini, etc.) - instructions : The system prompt that defines agent behavior When you call agent.run() , the agent: 1. Sends your message to OpenAI 2. Receives the response 3. Returns a RunResult with the output","title":"How It Works"},{"location":"CONTRIBUTING_DOCS/#next-steps_1","text":"Add tools to your agent Enable conversation memory ** Why this is good : ** - Shows real , tested code inline ( pulled from BasicTextOutputExample . java ) - Links to complete example for context - Multiple code snippets with region markers - Clear explanations after each code block - No copy - pasted code that could go stale ### Bad Example ``` markdown # Agent Documentation The Agent class is the main class for creating agents in the OpenAI Agent SDK for Java . ## Constructor The Agent class has a constructor that takes parameters . ## Methods ### run The run method runs the agent . ``` java // This code might not work agent . run ();","title":"Next Steps"},{"location":"CONTRIBUTING_DOCS/#see-also","text":"Other documentation ``` Problems : - No clear outcome - No working example - Code snippet not tested - Vague descriptions - No links to real code","title":"See Also"},{"location":"CONTRIBUTING_DOCS/#quick-checklist","text":"Before submitting documentation: [ ] Links point to real files (not fictional paths) [ ] Code examples are in src/main/java/.../examples/ and tested [ ] Writing is clear and concise [ ] Tested with mkdocs serve locally [ ] No copy-pasted code (only links or includes) [ ] Follows file naming conventions [ ] Reviewed by a human (if AI-assisted)","title":"Quick Checklist"},{"location":"CONTRIBUTING_DOCS/#questions","text":"Check existing docs in docs/ for examples Open a GitHub issue with the documentation label Ask in pull request reviews Last Updated : January 2026","title":"Questions?"},{"location":"PUBLISHING/","text":"This guide explains how to publish the OpenAI Agent SDK to Maven Central. Prerequisites Before you can publish, you need to set up the following: 1. Maven Central Account Create an account at Maven Central Portal Verify your namespace ai.acolite (already verified for this project) Generate publishing credentials (User Token) from your account page 2. GPG Key for Signing Maven Central requires all artifacts to be signed with GPG: # Generate a GPG key gpg --gen-key # List your keys gpg --list-secret-keys --keyid-format LONG # Export your private key (use the key ID from previous command) gpg --armor --export-secret-keys YOUR_KEY_ID 3. GitHub Secrets Add the following secrets to your GitHub repository (Settings \u2192 Secrets and variables \u2192 Actions): Secret Name Description OSSRH_USERNAME Your Maven Central user token username (from central.sonatype.com account page) OSSRH_PASSWORD Your Maven Central user token password (from central.sonatype.com account page) GPG_PRIVATE_KEY Your GPG private key (entire output from export command) GPG_PASSPHRASE The passphrase for your GPG key To get Maven Central credentials: 1. Go to https://central.sonatype.com/ and log in 2. Click your profile \u2192 Account 3. Click \"Generate User Token\" 4. Copy the username and password 5. Add them as OSSRH_USERNAME and OSSRH_PASSWORD in GitHub Secrets Publishing Process Option 1: Manual Workflow Trigger (Recommended) Step 1: Bump the version in pom.xml # Update version from 0.1.0-SNAPSHOT to 0.1.0 mvn versions:set -DnewVersion = 0 .1.0 -DgenerateBackupPoms = false # Commit the version bump git add pom.xml git commit -m \"Bump version to 0.1.0 for release\" git push origin main Step 2: Trigger the publish workflow Go to Actions \u2192 Publish to Maven Central Click Run workflow Choose whether to do a dry run (recommended first time) Click Run workflow The workflow will: - \u2705 Extract version from pom.xml - \u2705 Validate it's not a SNAPSHOT - \u2705 Run code quality checks (Spotless) - \u2705 Run unit tests - \u2705 Build and sign artifacts - \u2705 Deploy to Maven Central (OSSRH) - \u2705 Create a Git tag for the release Step 3: Bump to next SNAPSHOT version After publishing, bump to the next development version: # Bump to next SNAPSHOT mvn versions:set -DnewVersion = 0 .2.0-SNAPSHOT -DgenerateBackupPoms = false # Commit git add pom.xml git commit -m \"Bump version to 0.2.0-SNAPSHOT for development\" git push origin main Option 2: Local Publishing # Set version mvn versions:set -DnewVersion = 0 .1.0 # Deploy to Maven Central mvn clean deploy -P release # Create and push tag git tag -a v0.1.0 -m \"Release version 0.1.0\" git push origin v0.1.0 Dry Run Testing Before publishing for real, you should test with a dry run: Bump the version to a release version (e.g., 0.1.0 ) in pom.xml Commit and push to main Go to Actions \u2192 Publish to Maven Central Set Dry run to true Run the workflow This will build everything and show what would be published without actually deploying. If successful, run again with dry run off to publish for real. After Publishing Bump to next SNAPSHOT - Update pom.xml to next development version (see Step 3 above) Wait for sync - It can take 2-4 hours for artifacts to sync to Maven Central Verify on Maven Central - Check https://search.maven.org/ for your artifact Update documentation - Update version numbers in README and docs if needed Create GitHub Release - Create a release with release notes on GitHub Announce - Share the release in relevant channels Troubleshooting GPG Signing Fails Ensure your GPG key is not expired Verify the passphrase is correct Make sure the private key secret includes the full key (including -----BEGIN PGP PRIVATE KEY BLOCK----- ) Authentication Fails Verify your Sonatype credentials are correct If using a token, ensure it has the correct permissions Check that the serverId in pom.xml matches the GitHub secret name Artifacts Not Appearing Check the workflow logs for errors Verify the version is correct (not a snapshot) Wait 2-4 hours for Maven Central sync Check https://s01.oss.sonatype.org/ for staging status Version Guidelines Snapshots : 0.1.0-SNAPSHOT - Development versions Releases : 0.1.0 - Stable releases Follow Semantic Versioning : MAJOR version for incompatible API changes MINOR version for backwards-compatible functionality PATCH version for backwards-compatible bug fixes Security Never commit secrets to the repository Keep your GPG key secure and backed up Rotate credentials regularly Use GitHub's secret scanning to detect accidental commits","title":"PUBLISHING"},{"location":"PUBLISHING/#prerequisites","text":"Before you can publish, you need to set up the following:","title":"Prerequisites"},{"location":"PUBLISHING/#1-maven-central-account","text":"Create an account at Maven Central Portal Verify your namespace ai.acolite (already verified for this project) Generate publishing credentials (User Token) from your account page","title":"1. Maven Central Account"},{"location":"PUBLISHING/#2-gpg-key-for-signing","text":"Maven Central requires all artifacts to be signed with GPG: # Generate a GPG key gpg --gen-key # List your keys gpg --list-secret-keys --keyid-format LONG # Export your private key (use the key ID from previous command) gpg --armor --export-secret-keys YOUR_KEY_ID","title":"2. GPG Key for Signing"},{"location":"PUBLISHING/#3-github-secrets","text":"Add the following secrets to your GitHub repository (Settings \u2192 Secrets and variables \u2192 Actions): Secret Name Description OSSRH_USERNAME Your Maven Central user token username (from central.sonatype.com account page) OSSRH_PASSWORD Your Maven Central user token password (from central.sonatype.com account page) GPG_PRIVATE_KEY Your GPG private key (entire output from export command) GPG_PASSPHRASE The passphrase for your GPG key To get Maven Central credentials: 1. Go to https://central.sonatype.com/ and log in 2. Click your profile \u2192 Account 3. Click \"Generate User Token\" 4. Copy the username and password 5. Add them as OSSRH_USERNAME and OSSRH_PASSWORD in GitHub Secrets","title":"3. GitHub Secrets"},{"location":"PUBLISHING/#publishing-process","text":"","title":"Publishing Process"},{"location":"PUBLISHING/#option-1-manual-workflow-trigger-recommended","text":"Step 1: Bump the version in pom.xml # Update version from 0.1.0-SNAPSHOT to 0.1.0 mvn versions:set -DnewVersion = 0 .1.0 -DgenerateBackupPoms = false # Commit the version bump git add pom.xml git commit -m \"Bump version to 0.1.0 for release\" git push origin main Step 2: Trigger the publish workflow Go to Actions \u2192 Publish to Maven Central Click Run workflow Choose whether to do a dry run (recommended first time) Click Run workflow The workflow will: - \u2705 Extract version from pom.xml - \u2705 Validate it's not a SNAPSHOT - \u2705 Run code quality checks (Spotless) - \u2705 Run unit tests - \u2705 Build and sign artifacts - \u2705 Deploy to Maven Central (OSSRH) - \u2705 Create a Git tag for the release Step 3: Bump to next SNAPSHOT version After publishing, bump to the next development version: # Bump to next SNAPSHOT mvn versions:set -DnewVersion = 0 .2.0-SNAPSHOT -DgenerateBackupPoms = false # Commit git add pom.xml git commit -m \"Bump version to 0.2.0-SNAPSHOT for development\" git push origin main","title":"Option 1: Manual Workflow Trigger (Recommended)"},{"location":"PUBLISHING/#option-2-local-publishing","text":"# Set version mvn versions:set -DnewVersion = 0 .1.0 # Deploy to Maven Central mvn clean deploy -P release # Create and push tag git tag -a v0.1.0 -m \"Release version 0.1.0\" git push origin v0.1.0","title":"Option 2: Local Publishing"},{"location":"PUBLISHING/#dry-run-testing","text":"Before publishing for real, you should test with a dry run: Bump the version to a release version (e.g., 0.1.0 ) in pom.xml Commit and push to main Go to Actions \u2192 Publish to Maven Central Set Dry run to true Run the workflow This will build everything and show what would be published without actually deploying. If successful, run again with dry run off to publish for real.","title":"Dry Run Testing"},{"location":"PUBLISHING/#after-publishing","text":"Bump to next SNAPSHOT - Update pom.xml to next development version (see Step 3 above) Wait for sync - It can take 2-4 hours for artifacts to sync to Maven Central Verify on Maven Central - Check https://search.maven.org/ for your artifact Update documentation - Update version numbers in README and docs if needed Create GitHub Release - Create a release with release notes on GitHub Announce - Share the release in relevant channels","title":"After Publishing"},{"location":"PUBLISHING/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"PUBLISHING/#gpg-signing-fails","text":"Ensure your GPG key is not expired Verify the passphrase is correct Make sure the private key secret includes the full key (including -----BEGIN PGP PRIVATE KEY BLOCK----- )","title":"GPG Signing Fails"},{"location":"PUBLISHING/#authentication-fails","text":"Verify your Sonatype credentials are correct If using a token, ensure it has the correct permissions Check that the serverId in pom.xml matches the GitHub secret name","title":"Authentication Fails"},{"location":"PUBLISHING/#artifacts-not-appearing","text":"Check the workflow logs for errors Verify the version is correct (not a snapshot) Wait 2-4 hours for Maven Central sync Check https://s01.oss.sonatype.org/ for staging status","title":"Artifacts Not Appearing"},{"location":"PUBLISHING/#version-guidelines","text":"Snapshots : 0.1.0-SNAPSHOT - Development versions Releases : 0.1.0 - Stable releases Follow Semantic Versioning : MAJOR version for incompatible API changes MINOR version for backwards-compatible functionality PATCH version for backwards-compatible bug fixes","title":"Version Guidelines"},{"location":"PUBLISHING/#security","text":"Never commit secrets to the repository Keep your GPG key secure and backed up Rotate credentials regularly Use GitHub's secret scanning to detect accidental commits","title":"Security"},{"location":"quickstart/","text":"Get started with the OpenAI Agent SDK in 5 minutes. By the end of this guide, you'll have a working agent. A modern Java SDK for building AI agents with OpenAI's API, similar to the TypeScript OpenAI Agents SDK , following its public API and implementation patterns where possible. Prerequisites Java 21+ Maven or Gradle OpenAI API key 1. Install the SDK Add the dependency to your pom.xml : <dependency> <groupId> ai.acolite </groupId> <artifactId> openai-agent-sdk </artifactId> <version> 0.4.0 </version> </dependency> Or for Gradle ( build.gradle ): implementation 'ai.acolite:openai-agent-sdk:0.4.0' 2. Set Your API Key Export your OpenAI API key as an environment variable: export OPENAI_API_KEY = 'your-api-key-here' 3. Create Your First Agent Create a simple agent that answers a question: import ai.acolite.agentsdk.core.Agent ; import ai.acolite.agentsdk.core.RunResult ; import ai.acolite.agentsdk.core.Runner ; import ai.acolite.agentsdk.core.types.TextOutput ; import ai.acolite.agentsdk.core.types.UnknownContext ; public class Example { public static void main ( String [] args ) { Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Write a haiku about recursion in programming.\" ); System . out . println ( result . getFinalOutput ()); } } 4. Run It Compile and run: mvn exec:java -Dexec.mainClass = \"ai.acolite.agentsdk.examples.HelloWorld\" You should see the agent's response printed to the console. What's Next? Now that you have a basic agent, explore more features: Add custom tools - Let agents call functions Enable memory - Maintain conversation history Multi-agent workflows - Coordinate multiple agents Streaming responses - Real-time output Common Issues API Key Not Found If you see \"API key not found\", make sure you've exported OPENAI_API_KEY : echo $OPENAI_API_KEY # Should print your key Java Version Error The SDK requires Java 21+. Check your version: java -version # Should show 21 or higher Need Help? Troubleshooting Guide GitHub Issues API Reference","title":"Quickstart"},{"location":"quickstart/#prerequisites","text":"Java 21+ Maven or Gradle OpenAI API key","title":"Prerequisites"},{"location":"quickstart/#1-install-the-sdk","text":"Add the dependency to your pom.xml : <dependency> <groupId> ai.acolite </groupId> <artifactId> openai-agent-sdk </artifactId> <version> 0.4.0 </version> </dependency> Or for Gradle ( build.gradle ): implementation 'ai.acolite:openai-agent-sdk:0.4.0'","title":"1. Install the SDK"},{"location":"quickstart/#2-set-your-api-key","text":"Export your OpenAI API key as an environment variable: export OPENAI_API_KEY = 'your-api-key-here'","title":"2. Set Your API Key"},{"location":"quickstart/#3-create-your-first-agent","text":"Create a simple agent that answers a question: import ai.acolite.agentsdk.core.Agent ; import ai.acolite.agentsdk.core.RunResult ; import ai.acolite.agentsdk.core.Runner ; import ai.acolite.agentsdk.core.types.TextOutput ; import ai.acolite.agentsdk.core.types.UnknownContext ; public class Example { public static void main ( String [] args ) { Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Write a haiku about recursion in programming.\" ); System . out . println ( result . getFinalOutput ()); } }","title":"3. Create Your First Agent"},{"location":"quickstart/#4-run-it","text":"Compile and run: mvn exec:java -Dexec.mainClass = \"ai.acolite.agentsdk.examples.HelloWorld\" You should see the agent's response printed to the console.","title":"4. Run It"},{"location":"quickstart/#whats-next","text":"Now that you have a basic agent, explore more features: Add custom tools - Let agents call functions Enable memory - Maintain conversation history Multi-agent workflows - Coordinate multiple agents Streaming responses - Real-time output","title":"What's Next?"},{"location":"quickstart/#common-issues","text":"","title":"Common Issues"},{"location":"quickstart/#api-key-not-found","text":"If you see \"API key not found\", make sure you've exported OPENAI_API_KEY : echo $OPENAI_API_KEY # Should print your key","title":"API Key Not Found"},{"location":"quickstart/#java-version-error","text":"The SDK requires Java 21+. Check your version: java -version # Should show 21 or higher","title":"Java Version Error"},{"location":"quickstart/#need-help","text":"Troubleshooting Guide GitHub Issues API Reference","title":"Need Help?"},{"location":"api/","text":"Complete API documentation is available in the Javadoc: \ud83d\udcda View Full Javadoc \u2192 Core Packages ai.acolite.agentsdk.core - Core agent framework classes Agent - Main agent class Runner - Execute agents RunContext - Runtime context for tool execution FunctionTool - Tool interface ai.acolite.agentsdk.core.types - Type definitions TextOutput - Plain text output JsonSchemaOutput - Structured JSON output UnknownContext - Default context type ai.acolite.agentsdk.core.tracing - Tracing and observability TraceProvider - Trace management Trace - Trace context Span - Span tracking ai.acolite.agentsdk.core.sessions - Session management Session - Session interface MemorySession - In-memory sessions SQLiteSession - Persistent sessions Viewing Locally Generate Javadocs locally: mvn javadoc:javadoc open target/site/apidocs/index.html Or view directly in your IDE by hovering over classes and methods.","title":"API Reference"},{"location":"api/#core-packages","text":"ai.acolite.agentsdk.core - Core agent framework classes Agent - Main agent class Runner - Execute agents RunContext - Runtime context for tool execution FunctionTool - Tool interface ai.acolite.agentsdk.core.types - Type definitions TextOutput - Plain text output JsonSchemaOutput - Structured JSON output UnknownContext - Default context type ai.acolite.agentsdk.core.tracing - Tracing and observability TraceProvider - Trace management Trace - Trace context Span - Span tracking ai.acolite.agentsdk.core.sessions - Session management Session - Session interface MemorySession - In-memory sessions SQLiteSession - Persistent sessions","title":"Core Packages"},{"location":"api/#viewing-locally","text":"Generate Javadocs locally: mvn javadoc:javadoc open target/site/apidocs/index.html Or view directly in your IDE by hovering over classes and methods.","title":"Viewing Locally"},{"location":"guides/agents/","text":"Learn how to create and configure agents for AI-powered interactions. Overview Agents are the core building blocks of the SDK. Each agent encapsulates a model, instructions, and optional tools or output schemas. Agents are immutable once built, ensuring predictable behavior and thread safety. An agent is defined by two type parameters: TContext : Custom data passed during execution (use UnknownContext for simple cases) TOutput : The output type (e.g., TextOutput or JsonSchemaOutput<T> ) Creating a Basic Agent Create a simple text-based agent using the builder pattern: // Configures using OPENAI_API_KEY environment variable Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant. Keep responses concise and clear.\" ) . build (); Run the agent with a prompt: RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Explain what an AI agent is in one sentence.\" ); System . out . println ( result . getFinalOutput ()); // Output: \"An AI agent is a software system that uses AI to perceive its environment...\" View complete example \u2192 API Key Configuration The SDK automatically reads the OPENAI_API_KEY environment variable. System properties take precedence over environment variables if both are set. Configuration Options Model Selection Specify which OpenAI model to use. Defaults to \"gpt-4.1\" if not specified: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"FastAssistant\" ) . model ( \"gpt-4.1-mini\" ) // Faster, more cost-effective model . instructions ( \"You are a helpful assistant.\" ) . build (); Common model options: \"gpt-4.1\" - Latest GPT-4.1 model (default) \"gpt-4.1-mini\" - Faster, more cost-effective \"gpt-4-turbo\" - Previous generation \"gpt-3.5-turbo\" - Legacy model See the Models guide for the complete list and selection criteria. Instructions Instructions define your agent's behavior, personality, and response style: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"PythonExpert\" ) . instructions ( \"\"\" You are an expert Python developer. When answering questions: - Provide working code examples - Explain your reasoning - Follow PEP 8 style guidelines - Suggest best practices \"\"\" ) . build (); Instruction Design Clear, specific instructions improve agent performance. Include response format requirements, constraints, and any domain-specific guidelines. Agent Name The agent name appears in traces and logs. Use descriptive names for multi-agent systems: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"SupportAgent\" ) // Descriptive name for logging/tracing . instructions ( \"You are a customer support agent.\" ) . build (); Structured Output Use JsonSchemaOutput<T> to receive type-safe structured data instead of plain text: // Define your output structure public static class WeatherReport { public String location ; public int temperature ; public String conditions ; public String recommendation ; } // Create agent with structured output JsonSchemaOutput < WeatherReport > outputType = JsonSchemaOutput . of ( WeatherReport . class ); Agent < UnknownContext , JsonSchemaOutput < WeatherReport >> agent = Agent . < UnknownContext , JsonSchemaOutput < WeatherReport >> builder () . name ( \"WeatherAgent\" ) . instructions ( \"You are a weather assistant. Generate realistic weather data and recommendations.\" ) . outputType ( outputType ) . build (); // Run and access structured data RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What's the weather like in San Francisco today?\" ); if ( result . getFinalOutput () instanceof WeatherReport weather ) { System . out . println ( \"Location: \" + weather . location ); System . out . println ( \"Temperature: \" + weather . temperature + \"\u00b0F\" ); System . out . println ( \"Conditions: \" + weather . conditions ); } View complete example \u2192 When to Use Structured Output Use structured output when you need: Parsed data for further processing Type-safe access to response fields Integration with databases or APIs Consistent response formats Type Parameters Agents are parameterized by two types: TContext Custom context data available during agent execution. Use UnknownContext for simple agents: // Simple agent without custom context Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are helpful.\" ) . build (); For custom context with tool approval or usage tracking, define your own type: // Custom context with approval tracking public class MyContext { private Set < String > approvedActions = new HashSet <> (); public boolean canApprove ( String action ) { return ! approvedActions . contains ( action ); } } Agent < MyContext , TextOutput > agent = Agent . < MyContext , TextOutput > builder () . name ( \"ControlledAgent\" ) . instructions ( \"You are a controlled assistant.\" ) . build (); See the Run Context guide for advanced context patterns. TOutput The agent's output type. Two primary options: TextOutput - Plain text responses JsonSchemaOutput<T> - Structured data conforming to a schema // Text output Agent < UnknownContext , TextOutput > textAgent = /* ... */ ; // Structured output Agent < UnknownContext , JsonSchemaOutput < MyData >> structuredAgent = /* ... */ ; Immutability and Thread Safety Immutability Guarantee Each Agent instance is immutable once built. You can safely share agents across threads and reuse them for multiple runs without side effects. // Create an agent once Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"SharedAgent\" ) . instructions ( \"You are helpful.\" ) . build (); // Reuse safely across multiple executions RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"Question 1\" ); RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"Question 2\" ); // Agent state never changes Next Steps Running Agents - Execute agents and handle results Tools - Add custom functions for agents to call Sessions - Add conversation memory Handoffs - Build multi-agent systems Additional Resources BasicTextOutput.java - Simple text agent StructuredOutput.java - Structured output example API Reference - Complete Javadoc documentation","title":"Agents"},{"location":"guides/agents/#overview","text":"Agents are the core building blocks of the SDK. Each agent encapsulates a model, instructions, and optional tools or output schemas. Agents are immutable once built, ensuring predictable behavior and thread safety. An agent is defined by two type parameters: TContext : Custom data passed during execution (use UnknownContext for simple cases) TOutput : The output type (e.g., TextOutput or JsonSchemaOutput<T> )","title":"Overview"},{"location":"guides/agents/#creating-a-basic-agent","text":"Create a simple text-based agent using the builder pattern: // Configures using OPENAI_API_KEY environment variable Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant. Keep responses concise and clear.\" ) . build (); Run the agent with a prompt: RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Explain what an AI agent is in one sentence.\" ); System . out . println ( result . getFinalOutput ()); // Output: \"An AI agent is a software system that uses AI to perceive its environment...\" View complete example \u2192 API Key Configuration The SDK automatically reads the OPENAI_API_KEY environment variable. System properties take precedence over environment variables if both are set.","title":"Creating a Basic Agent"},{"location":"guides/agents/#configuration-options","text":"","title":"Configuration Options"},{"location":"guides/agents/#model-selection","text":"Specify which OpenAI model to use. Defaults to \"gpt-4.1\" if not specified: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"FastAssistant\" ) . model ( \"gpt-4.1-mini\" ) // Faster, more cost-effective model . instructions ( \"You are a helpful assistant.\" ) . build (); Common model options: \"gpt-4.1\" - Latest GPT-4.1 model (default) \"gpt-4.1-mini\" - Faster, more cost-effective \"gpt-4-turbo\" - Previous generation \"gpt-3.5-turbo\" - Legacy model See the Models guide for the complete list and selection criteria.","title":"Model Selection"},{"location":"guides/agents/#instructions","text":"Instructions define your agent's behavior, personality, and response style: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"PythonExpert\" ) . instructions ( \"\"\" You are an expert Python developer. When answering questions: - Provide working code examples - Explain your reasoning - Follow PEP 8 style guidelines - Suggest best practices \"\"\" ) . build (); Instruction Design Clear, specific instructions improve agent performance. Include response format requirements, constraints, and any domain-specific guidelines.","title":"Instructions"},{"location":"guides/agents/#agent-name","text":"The agent name appears in traces and logs. Use descriptive names for multi-agent systems: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"SupportAgent\" ) // Descriptive name for logging/tracing . instructions ( \"You are a customer support agent.\" ) . build ();","title":"Agent Name"},{"location":"guides/agents/#structured-output","text":"Use JsonSchemaOutput<T> to receive type-safe structured data instead of plain text: // Define your output structure public static class WeatherReport { public String location ; public int temperature ; public String conditions ; public String recommendation ; } // Create agent with structured output JsonSchemaOutput < WeatherReport > outputType = JsonSchemaOutput . of ( WeatherReport . class ); Agent < UnknownContext , JsonSchemaOutput < WeatherReport >> agent = Agent . < UnknownContext , JsonSchemaOutput < WeatherReport >> builder () . name ( \"WeatherAgent\" ) . instructions ( \"You are a weather assistant. Generate realistic weather data and recommendations.\" ) . outputType ( outputType ) . build (); // Run and access structured data RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What's the weather like in San Francisco today?\" ); if ( result . getFinalOutput () instanceof WeatherReport weather ) { System . out . println ( \"Location: \" + weather . location ); System . out . println ( \"Temperature: \" + weather . temperature + \"\u00b0F\" ); System . out . println ( \"Conditions: \" + weather . conditions ); } View complete example \u2192 When to Use Structured Output Use structured output when you need: Parsed data for further processing Type-safe access to response fields Integration with databases or APIs Consistent response formats","title":"Structured Output"},{"location":"guides/agents/#type-parameters","text":"Agents are parameterized by two types:","title":"Type Parameters"},{"location":"guides/agents/#tcontext","text":"Custom context data available during agent execution. Use UnknownContext for simple agents: // Simple agent without custom context Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are helpful.\" ) . build (); For custom context with tool approval or usage tracking, define your own type: // Custom context with approval tracking public class MyContext { private Set < String > approvedActions = new HashSet <> (); public boolean canApprove ( String action ) { return ! approvedActions . contains ( action ); } } Agent < MyContext , TextOutput > agent = Agent . < MyContext , TextOutput > builder () . name ( \"ControlledAgent\" ) . instructions ( \"You are a controlled assistant.\" ) . build (); See the Run Context guide for advanced context patterns.","title":"TContext"},{"location":"guides/agents/#toutput","text":"The agent's output type. Two primary options: TextOutput - Plain text responses JsonSchemaOutput<T> - Structured data conforming to a schema // Text output Agent < UnknownContext , TextOutput > textAgent = /* ... */ ; // Structured output Agent < UnknownContext , JsonSchemaOutput < MyData >> structuredAgent = /* ... */ ;","title":"TOutput"},{"location":"guides/agents/#immutability-and-thread-safety","text":"Immutability Guarantee Each Agent instance is immutable once built. You can safely share agents across threads and reuse them for multiple runs without side effects. // Create an agent once Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"SharedAgent\" ) . instructions ( \"You are helpful.\" ) . build (); // Reuse safely across multiple executions RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"Question 1\" ); RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"Question 2\" ); // Agent state never changes","title":"Immutability and Thread Safety"},{"location":"guides/agents/#next-steps","text":"Running Agents - Execute agents and handle results Tools - Add custom functions for agents to call Sessions - Add conversation memory Handoffs - Build multi-agent systems","title":"Next Steps"},{"location":"guides/agents/#additional-resources","text":"BasicTextOutput.java - Simple text agent StructuredOutput.java - Structured output example API Reference - Complete Javadoc documentation","title":"Additional Resources"},{"location":"guides/guardrails/","text":"Learn how to add safety constraints and validation to agent execution. Overview Guardrails provide safety checks and validation at key points in agent execution. They can inspect, modify, or block inputs, outputs, and tool calls based on your security and safety requirements. Three types of guardrails: Input Guardrails : Validate user inputs before processing Output Guardrails : Check agent responses before returning them Tool Guardrails : Monitor and control tool invocations Input Guardrails Input guardrails run before the agent processes user messages. Use them to filter inappropriate content, detect sensitive information, or enforce policies. Creating an Input Guardrail Implement InputGuardrail interface: public class ContentModerationGuardrail implements InputGuardrail { @Override public String getName () { return \"content_moderation\" ; } @Override public String getDescription () { return \"Blocks inappropriate or harmful content in user inputs\" ; } @Override public CompletableFuture < InputGuardrailResult > execute ( RunContext <?> context , List < AgentInputItem > inputs ) { return CompletableFuture . supplyAsync (() -> { // Check for inappropriate content for ( AgentInputItem item : inputs ) { if ( containsInappropriateContent ( item )) { // Block the input return InputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"Input contains inappropriate content\" ) . build (); } } // Allow the input return InputGuardrailResult . builder () . tripwireTriggered ( false ) . build (); }); } private boolean containsInappropriateContent ( AgentInputItem item ) { // Implement content moderation logic return false ; } } Using Input Guardrails Add guardrails to your agent: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . inputGuardrails ( List . of ( new ContentModerationGuardrail ())) . build (); // If input violates guardrail, execution stops with InputGuardrailTripwireTriggered RunResult < UnknownContext , ?> result = Runner . run ( agent , \"User message\" ); View complete example \u2192 Output Guardrails Output guardrails inspect agent responses before returning them to users. Use them to redact sensitive information, enforce formatting requirements, or filter inappropriate outputs. Creating an Output Guardrail public class PIIDetectionGuardrail implements OutputGuardrail { @Override public String getName () { return \"pii_detection\" ; } @Override public String getDescription () { return \"Detects and redacts personally identifiable information\" ; } @Override public CompletableFuture < OutputGuardrailResult > execute ( RunContext <?> context , Object output ) { return CompletableFuture . supplyAsync (() -> { if ( output instanceof String text ) { // Check for PII (emails, phone numbers, SSNs, etc.) if ( containsPII ( text )) { String redacted = redactPII ( text ); // Modify the output return OutputGuardrailResult . builder () . modifiedOutput ( redacted ) . tripwireTriggered ( false ) . message ( \"PII detected and redacted\" ) . build (); } } // Output is safe return OutputGuardrailResult . builder () . tripwireTriggered ( false ) . build (); }); } private boolean containsPII ( String text ) { // Check for email, phone, SSN patterns return text . matches ( \".*\\\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\b.*\" ); } private String redactPII ( String text ) { // Redact detected PII return text . replaceAll ( \"\\\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\b\" , \"[EMAIL REDACTED]\" ); } } Using Output Guardrails Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . outputGuardrails ( List . of ( new PIIDetectionGuardrail ())) . build (); // If output contains PII, it's automatically redacted RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What's John's email address?\" ); View complete example \u2192 Tool Guardrails Tool guardrails monitor tool inputs and outputs, providing fine-grained control over tool execution. Creating a Tool Guardrail public class SecretBlockingToolGuardrail implements ToolInputGuardrail { @Override public String getName () { return \"secret_blocking\" ; } @Override public String getDescription () { return \"Prevents tools from accessing secrets or credentials\" ; } @Override public CompletableFuture < ToolInputGuardrailResult > execute ( RunContext <?> context , String toolName , Object toolInput ) { return CompletableFuture . supplyAsync (() -> { // Check if tool is trying to access secrets if ( isAccessingSecrets ( toolName , toolInput )) { // Block the tool call return ToolInputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"Tool attempted to access secrets\" ) . build (); } // Allow the tool call return ToolInputGuardrailResult . builder () . tripwireTriggered ( false ) . build (); }); } private boolean isAccessingSecrets ( String toolName , Object input ) { // Check if input contains secret-related parameters return false ; } } Using Tool Guardrails Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . tools ( List . of ( new DatabaseTool (), new FileTool ())) . toolInputGuardrails ( List . of ( new SecretBlockingToolGuardrail ())) . build (); View complete example \u2192 Guardrail Behavior Blocking Execution Set tripwireTriggered(true) to block execution: return InputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"Policy violation detected\" ) . build (); This throws an exception and stops execution immediately. Modifying Content Modify outputs without blocking: return OutputGuardrailResult . builder () . modifiedOutput ( redactedText ) . tripwireTriggered ( false ) . message ( \"Content modified for safety\" ) . build (); The modified output is used instead of the original. Logging Only Run checks without affecting execution: return InputGuardrailResult . builder () . tripwireTriggered ( false ) . message ( \"Content flagged for review\" ) . build (); Log the message for auditing without blocking. Multiple Guardrails Run multiple guardrails in sequence: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"SecureAssistant\" ) . instructions ( \"You are a secure assistant.\" ) . inputGuardrails ( List . of ( new ContentModerationGuardrail (), new SpamDetectionGuardrail (), new InjectionDetectionGuardrail () )) . outputGuardrails ( List . of ( new PIIDetectionGuardrail (), new SensitiveInfoGuardrail () )) . toolInputGuardrails ( List . of ( new SecretBlockingToolGuardrail (), new PathTraversalGuardrail () )) . build (); Guardrails run in order. If any guardrail triggers, execution stops. Common Guardrail Patterns PII Detection and Redaction public class PIIGuardrail implements OutputGuardrail { private static final Pattern EMAIL = Pattern . compile ( \"\\\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\b\" , Pattern . CASE_INSENSITIVE ); private static final Pattern PHONE = Pattern . compile ( \"\\\\b\\\\d{3}[-.]?\\\\d{3}[-.]?\\\\d{4}\\\\b\" ); @Override public CompletableFuture < OutputGuardrailResult > execute ( RunContext <?> context , Object output ) { if ( output instanceof String text ) { String redacted = text ; redacted = EMAIL . matcher ( redacted ). replaceAll ( \"[EMAIL REDACTED]\" ); redacted = PHONE . matcher ( redacted ). replaceAll ( \"[PHONE REDACTED]\" ); if ( ! redacted . equals ( text )) { return CompletableFuture . completedFuture ( OutputGuardrailResult . builder () . modifiedOutput ( redacted ) . tripwireTriggered ( false ) . message ( \"PII redacted\" ) . build () ); } } return CompletableFuture . completedFuture ( OutputGuardrailResult . builder (). tripwireTriggered ( false ). build () ); } } SQL Injection Prevention public class SQLInjectionGuardrail implements ToolInputGuardrail { private static final Pattern SQL_INJECTION = Pattern . compile ( \".*(union|select|insert|update|delete|drop|create|alter)\\\\s+.*\" , Pattern . CASE_INSENSITIVE ); @Override public CompletableFuture < ToolInputGuardrailResult > execute ( RunContext <?> context , String toolName , Object toolInput ) { String inputStr = toolInput . toString (); if ( SQL_INJECTION . matcher ( inputStr ). matches ()) { return CompletableFuture . completedFuture ( ToolInputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"SQL injection attempt detected\" ) . build () ); } return CompletableFuture . completedFuture ( ToolInputGuardrailResult . builder (). tripwireTriggered ( false ). build () ); } } Rate Limiting public class RateLimitGuardrail implements InputGuardrail { private final Map < String , Queue < Long >> requestTimestamps = new ConcurrentHashMap <> (); private final int maxRequests = 10 ; private final long timeWindowMs = 60000 ; // 1 minute @Override public CompletableFuture < InputGuardrailResult > execute ( RunContext <?> context , List < AgentInputItem > inputs ) { String userId = context . getContext (). toString (); long now = System . currentTimeMillis (); Queue < Long > timestamps = requestTimestamps . computeIfAbsent ( userId , k -> new ConcurrentLinkedQueue <> () ); // Remove old timestamps timestamps . removeIf ( ts -> now - ts > timeWindowMs ); if ( timestamps . size () >= maxRequests ) { return CompletableFuture . completedFuture ( InputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"Rate limit exceeded\" ) . build () ); } timestamps . add ( now ); return CompletableFuture . completedFuture ( InputGuardrailResult . builder (). tripwireTriggered ( false ). build () ); } } Best Practices Guardrail Design Fast Execution : Keep guardrails lightweight to avoid latency Clear Messages : Provide informative messages when blocking Specific Checks : Create focused guardrails for specific threats Fail Secure : Default to blocking if uncertain Log Everything : Record all guardrail decisions for auditing Security Defense in Depth : Use multiple complementary guardrails Input Validation : Always validate user inputs Output Sanitization : Always check agent outputs Tool Restrictions : Limit tool capabilities via guardrails Context Awareness : Use RunContext for user-specific rules Performance Async Execution : Use CompletableFuture for I/O operations Caching : Cache expensive validation results Batch Processing : Process multiple items together when possible Early Exit : Check most likely violations first Resource Limits : Set timeouts for guardrail execution Common Pitfalls False Positives : Overly aggressive guardrails blocking legitimate use Incomplete Coverage : Missing edge cases in validation logic Performance Issues : Slow guardrails causing request timeouts Inconsistent Enforcement : Different guardrails with conflicting rules Poor Error Messages : Blocking without explaining why When to Use Guardrails Use guardrails for: Content moderation and safety PII detection and redaction Compliance enforcement (GDPR, HIPAA, etc.) Security threat prevention (injection, XSS, etc.) Rate limiting and abuse prevention Policy enforcement Don't use guardrails for: Complex business logic (use tools or context instead) Agent instruction modifications (use agent instructions) Performance optimization (use caching or async patterns) User preference handling (use context) Next Steps Run Context - Use context in guardrail logic Tools - Combine guardrails with tools Agents - Configure agents with guardrails Tracing - Monitor guardrail execution Additional Resources PIIDetectionGuardrail.java - Output guardrail example ContentModerationGuardrail.java - Input guardrail example SecretBlockingToolGuardrail.java - Tool guardrail example API Reference - Complete Javadoc documentation","title":"Guardrails"},{"location":"guides/guardrails/#overview","text":"Guardrails provide safety checks and validation at key points in agent execution. They can inspect, modify, or block inputs, outputs, and tool calls based on your security and safety requirements. Three types of guardrails: Input Guardrails : Validate user inputs before processing Output Guardrails : Check agent responses before returning them Tool Guardrails : Monitor and control tool invocations","title":"Overview"},{"location":"guides/guardrails/#input-guardrails","text":"Input guardrails run before the agent processes user messages. Use them to filter inappropriate content, detect sensitive information, or enforce policies.","title":"Input Guardrails"},{"location":"guides/guardrails/#creating-an-input-guardrail","text":"Implement InputGuardrail interface: public class ContentModerationGuardrail implements InputGuardrail { @Override public String getName () { return \"content_moderation\" ; } @Override public String getDescription () { return \"Blocks inappropriate or harmful content in user inputs\" ; } @Override public CompletableFuture < InputGuardrailResult > execute ( RunContext <?> context , List < AgentInputItem > inputs ) { return CompletableFuture . supplyAsync (() -> { // Check for inappropriate content for ( AgentInputItem item : inputs ) { if ( containsInappropriateContent ( item )) { // Block the input return InputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"Input contains inappropriate content\" ) . build (); } } // Allow the input return InputGuardrailResult . builder () . tripwireTriggered ( false ) . build (); }); } private boolean containsInappropriateContent ( AgentInputItem item ) { // Implement content moderation logic return false ; } }","title":"Creating an Input Guardrail"},{"location":"guides/guardrails/#using-input-guardrails","text":"Add guardrails to your agent: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . inputGuardrails ( List . of ( new ContentModerationGuardrail ())) . build (); // If input violates guardrail, execution stops with InputGuardrailTripwireTriggered RunResult < UnknownContext , ?> result = Runner . run ( agent , \"User message\" ); View complete example \u2192","title":"Using Input Guardrails"},{"location":"guides/guardrails/#output-guardrails","text":"Output guardrails inspect agent responses before returning them to users. Use them to redact sensitive information, enforce formatting requirements, or filter inappropriate outputs.","title":"Output Guardrails"},{"location":"guides/guardrails/#creating-an-output-guardrail","text":"public class PIIDetectionGuardrail implements OutputGuardrail { @Override public String getName () { return \"pii_detection\" ; } @Override public String getDescription () { return \"Detects and redacts personally identifiable information\" ; } @Override public CompletableFuture < OutputGuardrailResult > execute ( RunContext <?> context , Object output ) { return CompletableFuture . supplyAsync (() -> { if ( output instanceof String text ) { // Check for PII (emails, phone numbers, SSNs, etc.) if ( containsPII ( text )) { String redacted = redactPII ( text ); // Modify the output return OutputGuardrailResult . builder () . modifiedOutput ( redacted ) . tripwireTriggered ( false ) . message ( \"PII detected and redacted\" ) . build (); } } // Output is safe return OutputGuardrailResult . builder () . tripwireTriggered ( false ) . build (); }); } private boolean containsPII ( String text ) { // Check for email, phone, SSN patterns return text . matches ( \".*\\\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\b.*\" ); } private String redactPII ( String text ) { // Redact detected PII return text . replaceAll ( \"\\\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\b\" , \"[EMAIL REDACTED]\" ); } }","title":"Creating an Output Guardrail"},{"location":"guides/guardrails/#using-output-guardrails","text":"Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . outputGuardrails ( List . of ( new PIIDetectionGuardrail ())) . build (); // If output contains PII, it's automatically redacted RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What's John's email address?\" ); View complete example \u2192","title":"Using Output Guardrails"},{"location":"guides/guardrails/#tool-guardrails","text":"Tool guardrails monitor tool inputs and outputs, providing fine-grained control over tool execution.","title":"Tool Guardrails"},{"location":"guides/guardrails/#creating-a-tool-guardrail","text":"public class SecretBlockingToolGuardrail implements ToolInputGuardrail { @Override public String getName () { return \"secret_blocking\" ; } @Override public String getDescription () { return \"Prevents tools from accessing secrets or credentials\" ; } @Override public CompletableFuture < ToolInputGuardrailResult > execute ( RunContext <?> context , String toolName , Object toolInput ) { return CompletableFuture . supplyAsync (() -> { // Check if tool is trying to access secrets if ( isAccessingSecrets ( toolName , toolInput )) { // Block the tool call return ToolInputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"Tool attempted to access secrets\" ) . build (); } // Allow the tool call return ToolInputGuardrailResult . builder () . tripwireTriggered ( false ) . build (); }); } private boolean isAccessingSecrets ( String toolName , Object input ) { // Check if input contains secret-related parameters return false ; } }","title":"Creating a Tool Guardrail"},{"location":"guides/guardrails/#using-tool-guardrails","text":"Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . tools ( List . of ( new DatabaseTool (), new FileTool ())) . toolInputGuardrails ( List . of ( new SecretBlockingToolGuardrail ())) . build (); View complete example \u2192","title":"Using Tool Guardrails"},{"location":"guides/guardrails/#guardrail-behavior","text":"","title":"Guardrail Behavior"},{"location":"guides/guardrails/#blocking-execution","text":"Set tripwireTriggered(true) to block execution: return InputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"Policy violation detected\" ) . build (); This throws an exception and stops execution immediately.","title":"Blocking Execution"},{"location":"guides/guardrails/#modifying-content","text":"Modify outputs without blocking: return OutputGuardrailResult . builder () . modifiedOutput ( redactedText ) . tripwireTriggered ( false ) . message ( \"Content modified for safety\" ) . build (); The modified output is used instead of the original.","title":"Modifying Content"},{"location":"guides/guardrails/#logging-only","text":"Run checks without affecting execution: return InputGuardrailResult . builder () . tripwireTriggered ( false ) . message ( \"Content flagged for review\" ) . build (); Log the message for auditing without blocking.","title":"Logging Only"},{"location":"guides/guardrails/#multiple-guardrails","text":"Run multiple guardrails in sequence: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"SecureAssistant\" ) . instructions ( \"You are a secure assistant.\" ) . inputGuardrails ( List . of ( new ContentModerationGuardrail (), new SpamDetectionGuardrail (), new InjectionDetectionGuardrail () )) . outputGuardrails ( List . of ( new PIIDetectionGuardrail (), new SensitiveInfoGuardrail () )) . toolInputGuardrails ( List . of ( new SecretBlockingToolGuardrail (), new PathTraversalGuardrail () )) . build (); Guardrails run in order. If any guardrail triggers, execution stops.","title":"Multiple Guardrails"},{"location":"guides/guardrails/#common-guardrail-patterns","text":"","title":"Common Guardrail Patterns"},{"location":"guides/guardrails/#pii-detection-and-redaction","text":"public class PIIGuardrail implements OutputGuardrail { private static final Pattern EMAIL = Pattern . compile ( \"\\\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\b\" , Pattern . CASE_INSENSITIVE ); private static final Pattern PHONE = Pattern . compile ( \"\\\\b\\\\d{3}[-.]?\\\\d{3}[-.]?\\\\d{4}\\\\b\" ); @Override public CompletableFuture < OutputGuardrailResult > execute ( RunContext <?> context , Object output ) { if ( output instanceof String text ) { String redacted = text ; redacted = EMAIL . matcher ( redacted ). replaceAll ( \"[EMAIL REDACTED]\" ); redacted = PHONE . matcher ( redacted ). replaceAll ( \"[PHONE REDACTED]\" ); if ( ! redacted . equals ( text )) { return CompletableFuture . completedFuture ( OutputGuardrailResult . builder () . modifiedOutput ( redacted ) . tripwireTriggered ( false ) . message ( \"PII redacted\" ) . build () ); } } return CompletableFuture . completedFuture ( OutputGuardrailResult . builder (). tripwireTriggered ( false ). build () ); } }","title":"PII Detection and Redaction"},{"location":"guides/guardrails/#sql-injection-prevention","text":"public class SQLInjectionGuardrail implements ToolInputGuardrail { private static final Pattern SQL_INJECTION = Pattern . compile ( \".*(union|select|insert|update|delete|drop|create|alter)\\\\s+.*\" , Pattern . CASE_INSENSITIVE ); @Override public CompletableFuture < ToolInputGuardrailResult > execute ( RunContext <?> context , String toolName , Object toolInput ) { String inputStr = toolInput . toString (); if ( SQL_INJECTION . matcher ( inputStr ). matches ()) { return CompletableFuture . completedFuture ( ToolInputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"SQL injection attempt detected\" ) . build () ); } return CompletableFuture . completedFuture ( ToolInputGuardrailResult . builder (). tripwireTriggered ( false ). build () ); } }","title":"SQL Injection Prevention"},{"location":"guides/guardrails/#rate-limiting","text":"public class RateLimitGuardrail implements InputGuardrail { private final Map < String , Queue < Long >> requestTimestamps = new ConcurrentHashMap <> (); private final int maxRequests = 10 ; private final long timeWindowMs = 60000 ; // 1 minute @Override public CompletableFuture < InputGuardrailResult > execute ( RunContext <?> context , List < AgentInputItem > inputs ) { String userId = context . getContext (). toString (); long now = System . currentTimeMillis (); Queue < Long > timestamps = requestTimestamps . computeIfAbsent ( userId , k -> new ConcurrentLinkedQueue <> () ); // Remove old timestamps timestamps . removeIf ( ts -> now - ts > timeWindowMs ); if ( timestamps . size () >= maxRequests ) { return CompletableFuture . completedFuture ( InputGuardrailResult . builder () . tripwireTriggered ( true ) . message ( \"Rate limit exceeded\" ) . build () ); } timestamps . add ( now ); return CompletableFuture . completedFuture ( InputGuardrailResult . builder (). tripwireTriggered ( false ). build () ); } }","title":"Rate Limiting"},{"location":"guides/guardrails/#best-practices","text":"Guardrail Design Fast Execution : Keep guardrails lightweight to avoid latency Clear Messages : Provide informative messages when blocking Specific Checks : Create focused guardrails for specific threats Fail Secure : Default to blocking if uncertain Log Everything : Record all guardrail decisions for auditing Security Defense in Depth : Use multiple complementary guardrails Input Validation : Always validate user inputs Output Sanitization : Always check agent outputs Tool Restrictions : Limit tool capabilities via guardrails Context Awareness : Use RunContext for user-specific rules Performance Async Execution : Use CompletableFuture for I/O operations Caching : Cache expensive validation results Batch Processing : Process multiple items together when possible Early Exit : Check most likely violations first Resource Limits : Set timeouts for guardrail execution Common Pitfalls False Positives : Overly aggressive guardrails blocking legitimate use Incomplete Coverage : Missing edge cases in validation logic Performance Issues : Slow guardrails causing request timeouts Inconsistent Enforcement : Different guardrails with conflicting rules Poor Error Messages : Blocking without explaining why","title":"Best Practices"},{"location":"guides/guardrails/#when-to-use-guardrails","text":"Use guardrails for: Content moderation and safety PII detection and redaction Compliance enforcement (GDPR, HIPAA, etc.) Security threat prevention (injection, XSS, etc.) Rate limiting and abuse prevention Policy enforcement Don't use guardrails for: Complex business logic (use tools or context instead) Agent instruction modifications (use agent instructions) Performance optimization (use caching or async patterns) User preference handling (use context)","title":"When to Use Guardrails"},{"location":"guides/guardrails/#next-steps","text":"Run Context - Use context in guardrail logic Tools - Combine guardrails with tools Agents - Configure agents with guardrails Tracing - Monitor guardrail execution","title":"Next Steps"},{"location":"guides/guardrails/#additional-resources","text":"PIIDetectionGuardrail.java - Output guardrail example ContentModerationGuardrail.java - Input guardrail example SecretBlockingToolGuardrail.java - Tool guardrail example API Reference - Complete Javadoc documentation","title":"Additional Resources"},{"location":"guides/handoffs/","text":"Learn how to build multi-agent systems where specialized agents collaborate on complex tasks. Overview Handoffs enable conversations to transfer between specialized agents. A triage agent routes requests to experts, each handling specific domains like billing, technical support, or account management. This pattern improves response quality by leveraging specialized knowledge and clear task boundaries. Key benefits: Specialization : Each agent focuses on its expertise Maintainability : Modify specialist agents independently Scalability : Add new specialists without changing existing agents Clarity : Clean separation of responsibilities Creating a Simple Handoff Define a specialist agent with a handoffDescription , then configure the triage agent to hand off to it: // Create a specialist agent for technical support Agent < UnknownContext , TextOutput > supportAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Technical Support\" ) . instructions ( \"You are a technical support specialist. \" + \"Help users troubleshoot technical issues, provide clear solutions, \" + \"and explain technical concepts in simple terms.\" ) . handoffDescription ( \"Hands off technical support and troubleshooting questions to this agent\" ) . build (); // Create a triage agent that can hand off to the specialist Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage Agent\" ) . instructions ( \"You are a triage agent. Your ONLY job is to transfer users to specialists. \" + \"For ANY technical problem, crash, or bug, you MUST call transfer_to_Technical_Support. \" + \"DO NOT try to help directly. ALWAYS transfer.\" ) . handoffs ( List . of ( supportAgent )) . build (); // Run with a technical question - triggers automatic handoff RunResult < UnknownContext , ?> result = Runner . run ( triageAgent , \"My application keeps crashing when I click the save button. How do I fix this?\" ); System . out . println ( result . getFinalOutput ()); // Output from Technical Support specialist: \"Let's troubleshoot this crash...\" View complete example \u2192 How Handoffs Work Registration : Triage agent registers specialists via .handoffs(List.of(...)) Tool Generation : SDK generates transfer_to_<AgentName> functions automatically Agent Decision : Triage agent calls the appropriate transfer function Execution Transfer : Specialist agent takes over and handles the request Final Response : User receives the specialist's response The SDK handles all transfer mechanics automatically. You define specialists and routing logic through instructions. Multiple Specialists Configure a triage agent to route to multiple specialists: // Create specialized agents Agent < UnknownContext , TextOutput > billingAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Billing Specialist\" ) . instructions ( \"You are a billing specialist. Help users with payment issues.\" ) . handoffDescription ( \"Handles billing, payments, refunds, and invoice questions\" ) . build (); Agent < UnknownContext , TextOutput > technicalAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Technical Support\" ) . instructions ( \"You are a technical support specialist. Help with bugs and crashes.\" ) . handoffDescription ( \"Handles technical issues, bugs, and troubleshooting\" ) . build (); Agent < UnknownContext , TextOutput > accountAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Account Manager\" ) . instructions ( \"You are an account manager. Help with account settings.\" ) . handoffDescription ( \"Handles account management and settings\" ) . build (); // Create triage agent with multiple handoff options Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Customer Service Triage\" ) . instructions ( \"\"\" You are a triage agent. Your ONLY job is to transfer to specialists. DO NOT help directly. You MUST call the appropriate transfer function: - For billing, payments, refunds: call transfer_to_Billing_Specialist - For technical issues, bugs, crashes: call transfer_to_Technical_Support - For account settings, profile: call transfer_to_Account_Manager ALWAYS transfer. DO NOT answer questions yourself. \"\"\" ) . handoffs ( List . of ( billingAgent , technicalAgent , accountAgent )) . build (); // Test different question types RunResult < UnknownContext , ?> result1 = Runner . run ( triageAgent , \"I was charged twice for my subscription this month\" ); // Routes to Billing Specialist RunResult < UnknownContext , ?> result2 = Runner . run ( triageAgent , \"How do I change my email address?\" ); // Routes to Account Manager RunResult < UnknownContext , ?> result3 = Runner . run ( triageAgent , \"The app crashes every time I try to export data\" ); // Routes to Technical Support The triage agent analyzes each question and selects the appropriate specialist automatically. Handoff Description The handoffDescription explains when to use each specialist. This description is presented to the triage agent as part of the transfer function documentation: Agent < UnknownContext , TextOutput > specialist = Agent . < UnknownContext , TextOutput > builder () . name ( \"Billing Specialist\" ) . instructions ( \"Handle billing questions...\" ) . handoffDescription ( \"Handles billing, payments, refunds, and invoice questions\" ) . build (); Writing Good Handoff Descriptions Be specific about the specialist's domain List key topics or question types Use clear, action-oriented language Avoid overlap between specialists Keep descriptions concise (1-2 sentences) Tracking Handoffs Monitor handoff execution using RunResult : RunResult < UnknownContext , ?> result = Runner . run ( triageAgent , \"My question...\" ); // Count handoffs long handoffCount = result . getNewItems (). stream () . filter ( item -> item instanceof RunHandoffOutputItem ) . count (); System . out . println ( \"Handoffs executed: \" + handoffCount ); // Get handoff details result . getNewItems (). stream () . filter ( item -> item instanceof RunHandoffOutputItem ) . map ( item -> ( RunHandoffOutputItem ) item ) . forEach ( handoff -> { System . out . println ( \"From: \" + handoff . getFromAgent ()); System . out . println ( \"To: \" + handoff . getToAgent ()); }); Track handoffs for: Debugging routing logic Analyzing specialist utilization Monitoring conversation flow Improving triage instructions Triage Agent Patterns Direct Transfer Pattern Triage agent immediately transfers without responding: Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"\"\" You are a triage agent. Your ONLY job is to transfer to specialists. DO NOT answer questions. DO NOT provide information. Immediately call the appropriate transfer function. \"\"\" ) . handoffs ( List . of ( specialist1 , specialist2 , specialist3 )) . build (); Use when : You want specialists to handle all interactions. Greeting + Transfer Pattern Triage agent greets briefly, then transfers: Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"\"\" You are a triage agent. Greet the user briefly, then transfer: 1. Acknowledge their question in one sentence 2. Immediately call the appropriate transfer function DO NOT attempt to answer. Let specialists handle all questions. \"\"\" ) . handoffs ( List . of ( specialist1 , specialist2 , specialist3 )) . build (); Use when : You want a friendly greeting before specialist engagement. Smart Routing Pattern Triage agent clarifies ambiguous requests before transferring: Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"\"\" You are a triage agent. For clear requests, transfer immediately. For ambiguous requests, ask ONE clarifying question, then transfer. Never provide answers - specialists handle all questions. \"\"\" ) . handoffs ( List . of ( specialist1 , specialist2 , specialist3 )) . build (); Use when : Questions might be ambiguous and benefit from clarification. Nested Handoffs Specialists can themselves have handoffs to create hierarchical routing: // Level 2: Sub-specialists Agent < UnknownContext , TextOutput > refundSpecialist = /* ... */ ; Agent < UnknownContext , TextOutput > invoiceSpecialist = /* ... */ ; // Level 1: Domain specialist with sub-specialists Agent < UnknownContext , TextOutput > billingAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Billing Specialist\" ) . instructions ( \"\"\" You are a billing specialist. For general billing questions, answer directly. For refunds, call transfer_to_Refund_Specialist. For invoice issues, call transfer_to_Invoice_Specialist. \"\"\" ) . handoffDescription ( \"Handles billing, payments, and financial questions\" ) . handoffs ( List . of ( refundSpecialist , invoiceSpecialist )) . build (); // Level 0: Triage Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"Route to appropriate specialist...\" ) . handoffs ( List . of ( billingAgent , /* other specialists */ )) . build (); This creates a three-level hierarchy: Triage \u2192 Billing \u2192 Refund/Invoice specialists. Session Management with Handoffs Use sessions to maintain context across handoffs: Session session = new MemorySession ( \"customer-123\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // First interaction - routes to billing RunResult < UnknownContext , ?> result1 = Runner . run ( triageAgent , \"I was charged incorrectly\" , config ); // Follow-up question - specialist remembers context RunResult < UnknownContext , ?> result2 = Runner . run ( triageAgent , \"Can you refund the extra charge?\" , config ); // Context is preserved across handoffs Specialists access full conversation history, including interactions before the handoff. Best Practices Specialist Design Narrow Scope : Each specialist handles one clear domain Complete Instructions : Provide comprehensive guidance for the specialist's area Avoid Overlaps : Clearly distinguish between specialist domains Test Coverage : Verify all question types route correctly Clear Boundaries : Use handoff descriptions to define scope explicitly Triage Instructions Explicit Routing : Clearly specify which specialist handles what Prevent Answering : Instruct triage not to answer questions directly Function Names : Reference exact transfer function names in instructions Edge Cases : Address ambiguous scenarios explicitly Mandatory Transfers : Use strong language like \"MUST transfer\" or \"ALWAYS call\" Performance Minimize Turns : Design for single-handoff scenarios Session Reuse : Use sessions to reduce context repetition Monitor Costs : Track token usage across multi-agent conversations Test Routing : Validate triage logic with representative questions Measure Accuracy : Monitor misrouted questions Common Pitfalls Triage Answering : Triage agents trying to help instead of transferring Unclear Boundaries : Overlapping specialist domains causing confusion Missing Descriptions : Handoff descriptions that don't guide routing Excessive Nesting : Too many handoff levels increasing complexity Context Loss : Not using sessions for multi-turn handoff conversations When to Use Handoffs Use handoffs when: Different questions require different expertise You want modular, independent agent development Routing logic can be clearly defined You need to scale specialists independently Don't use handoffs when: A single agent can handle all scenarios Questions require seamless context across all topics Handoff overhead outweighs specialization benefits Routing logic is too complex or ambiguous Next Steps Run Context - Custom context and tool approval across handoffs Sessions - Maintain conversation memory through handoffs Tools - Add specialized tools to specialist agents Tracing - Monitor handoff execution in detail Additional Resources AgentHandoffExample.java - Complete handoff examples API Reference - Complete Javadoc documentation","title":"Handoffs"},{"location":"guides/handoffs/#overview","text":"Handoffs enable conversations to transfer between specialized agents. A triage agent routes requests to experts, each handling specific domains like billing, technical support, or account management. This pattern improves response quality by leveraging specialized knowledge and clear task boundaries. Key benefits: Specialization : Each agent focuses on its expertise Maintainability : Modify specialist agents independently Scalability : Add new specialists without changing existing agents Clarity : Clean separation of responsibilities","title":"Overview"},{"location":"guides/handoffs/#creating-a-simple-handoff","text":"Define a specialist agent with a handoffDescription , then configure the triage agent to hand off to it: // Create a specialist agent for technical support Agent < UnknownContext , TextOutput > supportAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Technical Support\" ) . instructions ( \"You are a technical support specialist. \" + \"Help users troubleshoot technical issues, provide clear solutions, \" + \"and explain technical concepts in simple terms.\" ) . handoffDescription ( \"Hands off technical support and troubleshooting questions to this agent\" ) . build (); // Create a triage agent that can hand off to the specialist Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage Agent\" ) . instructions ( \"You are a triage agent. Your ONLY job is to transfer users to specialists. \" + \"For ANY technical problem, crash, or bug, you MUST call transfer_to_Technical_Support. \" + \"DO NOT try to help directly. ALWAYS transfer.\" ) . handoffs ( List . of ( supportAgent )) . build (); // Run with a technical question - triggers automatic handoff RunResult < UnknownContext , ?> result = Runner . run ( triageAgent , \"My application keeps crashing when I click the save button. How do I fix this?\" ); System . out . println ( result . getFinalOutput ()); // Output from Technical Support specialist: \"Let's troubleshoot this crash...\" View complete example \u2192","title":"Creating a Simple Handoff"},{"location":"guides/handoffs/#how-handoffs-work","text":"Registration : Triage agent registers specialists via .handoffs(List.of(...)) Tool Generation : SDK generates transfer_to_<AgentName> functions automatically Agent Decision : Triage agent calls the appropriate transfer function Execution Transfer : Specialist agent takes over and handles the request Final Response : User receives the specialist's response The SDK handles all transfer mechanics automatically. You define specialists and routing logic through instructions.","title":"How Handoffs Work"},{"location":"guides/handoffs/#multiple-specialists","text":"Configure a triage agent to route to multiple specialists: // Create specialized agents Agent < UnknownContext , TextOutput > billingAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Billing Specialist\" ) . instructions ( \"You are a billing specialist. Help users with payment issues.\" ) . handoffDescription ( \"Handles billing, payments, refunds, and invoice questions\" ) . build (); Agent < UnknownContext , TextOutput > technicalAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Technical Support\" ) . instructions ( \"You are a technical support specialist. Help with bugs and crashes.\" ) . handoffDescription ( \"Handles technical issues, bugs, and troubleshooting\" ) . build (); Agent < UnknownContext , TextOutput > accountAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Account Manager\" ) . instructions ( \"You are an account manager. Help with account settings.\" ) . handoffDescription ( \"Handles account management and settings\" ) . build (); // Create triage agent with multiple handoff options Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Customer Service Triage\" ) . instructions ( \"\"\" You are a triage agent. Your ONLY job is to transfer to specialists. DO NOT help directly. You MUST call the appropriate transfer function: - For billing, payments, refunds: call transfer_to_Billing_Specialist - For technical issues, bugs, crashes: call transfer_to_Technical_Support - For account settings, profile: call transfer_to_Account_Manager ALWAYS transfer. DO NOT answer questions yourself. \"\"\" ) . handoffs ( List . of ( billingAgent , technicalAgent , accountAgent )) . build (); // Test different question types RunResult < UnknownContext , ?> result1 = Runner . run ( triageAgent , \"I was charged twice for my subscription this month\" ); // Routes to Billing Specialist RunResult < UnknownContext , ?> result2 = Runner . run ( triageAgent , \"How do I change my email address?\" ); // Routes to Account Manager RunResult < UnknownContext , ?> result3 = Runner . run ( triageAgent , \"The app crashes every time I try to export data\" ); // Routes to Technical Support The triage agent analyzes each question and selects the appropriate specialist automatically.","title":"Multiple Specialists"},{"location":"guides/handoffs/#handoff-description","text":"The handoffDescription explains when to use each specialist. This description is presented to the triage agent as part of the transfer function documentation: Agent < UnknownContext , TextOutput > specialist = Agent . < UnknownContext , TextOutput > builder () . name ( \"Billing Specialist\" ) . instructions ( \"Handle billing questions...\" ) . handoffDescription ( \"Handles billing, payments, refunds, and invoice questions\" ) . build (); Writing Good Handoff Descriptions Be specific about the specialist's domain List key topics or question types Use clear, action-oriented language Avoid overlap between specialists Keep descriptions concise (1-2 sentences)","title":"Handoff Description"},{"location":"guides/handoffs/#tracking-handoffs","text":"Monitor handoff execution using RunResult : RunResult < UnknownContext , ?> result = Runner . run ( triageAgent , \"My question...\" ); // Count handoffs long handoffCount = result . getNewItems (). stream () . filter ( item -> item instanceof RunHandoffOutputItem ) . count (); System . out . println ( \"Handoffs executed: \" + handoffCount ); // Get handoff details result . getNewItems (). stream () . filter ( item -> item instanceof RunHandoffOutputItem ) . map ( item -> ( RunHandoffOutputItem ) item ) . forEach ( handoff -> { System . out . println ( \"From: \" + handoff . getFromAgent ()); System . out . println ( \"To: \" + handoff . getToAgent ()); }); Track handoffs for: Debugging routing logic Analyzing specialist utilization Monitoring conversation flow Improving triage instructions","title":"Tracking Handoffs"},{"location":"guides/handoffs/#triage-agent-patterns","text":"","title":"Triage Agent Patterns"},{"location":"guides/handoffs/#direct-transfer-pattern","text":"Triage agent immediately transfers without responding: Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"\"\" You are a triage agent. Your ONLY job is to transfer to specialists. DO NOT answer questions. DO NOT provide information. Immediately call the appropriate transfer function. \"\"\" ) . handoffs ( List . of ( specialist1 , specialist2 , specialist3 )) . build (); Use when : You want specialists to handle all interactions.","title":"Direct Transfer Pattern"},{"location":"guides/handoffs/#greeting-transfer-pattern","text":"Triage agent greets briefly, then transfers: Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"\"\" You are a triage agent. Greet the user briefly, then transfer: 1. Acknowledge their question in one sentence 2. Immediately call the appropriate transfer function DO NOT attempt to answer. Let specialists handle all questions. \"\"\" ) . handoffs ( List . of ( specialist1 , specialist2 , specialist3 )) . build (); Use when : You want a friendly greeting before specialist engagement.","title":"Greeting + Transfer Pattern"},{"location":"guides/handoffs/#smart-routing-pattern","text":"Triage agent clarifies ambiguous requests before transferring: Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"\"\" You are a triage agent. For clear requests, transfer immediately. For ambiguous requests, ask ONE clarifying question, then transfer. Never provide answers - specialists handle all questions. \"\"\" ) . handoffs ( List . of ( specialist1 , specialist2 , specialist3 )) . build (); Use when : Questions might be ambiguous and benefit from clarification.","title":"Smart Routing Pattern"},{"location":"guides/handoffs/#nested-handoffs","text":"Specialists can themselves have handoffs to create hierarchical routing: // Level 2: Sub-specialists Agent < UnknownContext , TextOutput > refundSpecialist = /* ... */ ; Agent < UnknownContext , TextOutput > invoiceSpecialist = /* ... */ ; // Level 1: Domain specialist with sub-specialists Agent < UnknownContext , TextOutput > billingAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Billing Specialist\" ) . instructions ( \"\"\" You are a billing specialist. For general billing questions, answer directly. For refunds, call transfer_to_Refund_Specialist. For invoice issues, call transfer_to_Invoice_Specialist. \"\"\" ) . handoffDescription ( \"Handles billing, payments, and financial questions\" ) . handoffs ( List . of ( refundSpecialist , invoiceSpecialist )) . build (); // Level 0: Triage Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"Route to appropriate specialist...\" ) . handoffs ( List . of ( billingAgent , /* other specialists */ )) . build (); This creates a three-level hierarchy: Triage \u2192 Billing \u2192 Refund/Invoice specialists.","title":"Nested Handoffs"},{"location":"guides/handoffs/#session-management-with-handoffs","text":"Use sessions to maintain context across handoffs: Session session = new MemorySession ( \"customer-123\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // First interaction - routes to billing RunResult < UnknownContext , ?> result1 = Runner . run ( triageAgent , \"I was charged incorrectly\" , config ); // Follow-up question - specialist remembers context RunResult < UnknownContext , ?> result2 = Runner . run ( triageAgent , \"Can you refund the extra charge?\" , config ); // Context is preserved across handoffs Specialists access full conversation history, including interactions before the handoff.","title":"Session Management with Handoffs"},{"location":"guides/handoffs/#best-practices","text":"Specialist Design Narrow Scope : Each specialist handles one clear domain Complete Instructions : Provide comprehensive guidance for the specialist's area Avoid Overlaps : Clearly distinguish between specialist domains Test Coverage : Verify all question types route correctly Clear Boundaries : Use handoff descriptions to define scope explicitly Triage Instructions Explicit Routing : Clearly specify which specialist handles what Prevent Answering : Instruct triage not to answer questions directly Function Names : Reference exact transfer function names in instructions Edge Cases : Address ambiguous scenarios explicitly Mandatory Transfers : Use strong language like \"MUST transfer\" or \"ALWAYS call\" Performance Minimize Turns : Design for single-handoff scenarios Session Reuse : Use sessions to reduce context repetition Monitor Costs : Track token usage across multi-agent conversations Test Routing : Validate triage logic with representative questions Measure Accuracy : Monitor misrouted questions Common Pitfalls Triage Answering : Triage agents trying to help instead of transferring Unclear Boundaries : Overlapping specialist domains causing confusion Missing Descriptions : Handoff descriptions that don't guide routing Excessive Nesting : Too many handoff levels increasing complexity Context Loss : Not using sessions for multi-turn handoff conversations","title":"Best Practices"},{"location":"guides/handoffs/#when-to-use-handoffs","text":"Use handoffs when: Different questions require different expertise You want modular, independent agent development Routing logic can be clearly defined You need to scale specialists independently Don't use handoffs when: A single agent can handle all scenarios Questions require seamless context across all topics Handoff overhead outweighs specialization benefits Routing logic is too complex or ambiguous","title":"When to Use Handoffs"},{"location":"guides/handoffs/#next-steps","text":"Run Context - Custom context and tool approval across handoffs Sessions - Maintain conversation memory through handoffs Tools - Add specialized tools to specialist agents Tracing - Monitor handoff execution in detail","title":"Next Steps"},{"location":"guides/handoffs/#additional-resources","text":"AgentHandoffExample.java - Complete handoff examples API Reference - Complete Javadoc documentation","title":"Additional Resources"},{"location":"guides/models/","text":"This guide covers model selection, defaults, and how models are resolved at runtime. Overview Model configuration is controlled in three places: Agent default model ( Agent.model ) Run-time override ( RunConfig.model ) Provider behavior ( ModelProvider ) Defaults and Overrides Model selection follows this order: RunConfig.model if provided. Agent.model if provided. OPENAI_MODEL environment variable. Fallback to gpt-4.1 . Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . model ( \"gpt-4.1-mini\" ) . build (); RunConfig config = RunConfig . builder (). model ( \"gpt-4.1\" ). build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Hello\" , config ); Model Providers The SDK uses a ModelProvider to resolve a Model by name. Defaults: Provider: OpenAIProvider API key: OPENAI_API_KEY Implementation: OpenAIResponsesModel (OpenAI Responses API) Custom provider example: public class MyProvider implements ModelProvider { @Override public CompletableFuture < Model > getModel ( String modelName ) { return CompletableFuture . completedFuture ( new MyModel ( modelName )); } } RunConfig config = RunConfig . builder (). modelProvider ( new MyProvider ()). model ( \"my-model\" ). build (); Model Timeouts RunConfig.modelTimeoutMs sets per-call timeout (default: 60000ms). RunConfig.timeoutMs sets overall run timeout. RunConfig config = RunConfig . builder () . modelTimeoutMs ( 30000L ) . timeoutMs ( 120000L ) . build (); Structured Outputs When you use JsonSchemaOutput , the OpenAI provider uses structured responses under the hood. This lets you return typed data instead of raw text. Model Settings (Advanced) ModelSettings exists and is plumbed through Agent , but it is not fully exposed yet. Expect this surface to expand as more configuration is wired up. Notes OpenAI model IDs are account-specific and may change over time. If a model name is rejected, verify the ID in your OpenAI account and ensure your provider supports it.","title":"Models"},{"location":"guides/models/#overview","text":"Model configuration is controlled in three places: Agent default model ( Agent.model ) Run-time override ( RunConfig.model ) Provider behavior ( ModelProvider )","title":"Overview"},{"location":"guides/models/#defaults-and-overrides","text":"Model selection follows this order: RunConfig.model if provided. Agent.model if provided. OPENAI_MODEL environment variable. Fallback to gpt-4.1 . Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . model ( \"gpt-4.1-mini\" ) . build (); RunConfig config = RunConfig . builder (). model ( \"gpt-4.1\" ). build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Hello\" , config );","title":"Defaults and Overrides"},{"location":"guides/models/#model-providers","text":"The SDK uses a ModelProvider to resolve a Model by name. Defaults: Provider: OpenAIProvider API key: OPENAI_API_KEY Implementation: OpenAIResponsesModel (OpenAI Responses API) Custom provider example: public class MyProvider implements ModelProvider { @Override public CompletableFuture < Model > getModel ( String modelName ) { return CompletableFuture . completedFuture ( new MyModel ( modelName )); } } RunConfig config = RunConfig . builder (). modelProvider ( new MyProvider ()). model ( \"my-model\" ). build ();","title":"Model Providers"},{"location":"guides/models/#model-timeouts","text":"RunConfig.modelTimeoutMs sets per-call timeout (default: 60000ms). RunConfig.timeoutMs sets overall run timeout. RunConfig config = RunConfig . builder () . modelTimeoutMs ( 30000L ) . timeoutMs ( 120000L ) . build ();","title":"Model Timeouts"},{"location":"guides/models/#structured-outputs","text":"When you use JsonSchemaOutput , the OpenAI provider uses structured responses under the hood. This lets you return typed data instead of raw text.","title":"Structured Outputs"},{"location":"guides/models/#model-settings-advanced","text":"ModelSettings exists and is plumbed through Agent , but it is not fully exposed yet. Expect this surface to expand as more configuration is wired up.","title":"Model Settings (Advanced)"},{"location":"guides/models/#notes","text":"OpenAI model IDs are account-specific and may change over time. If a model name is rejected, verify the ID in your OpenAI account and ensure your provider supports it.","title":"Notes"},{"location":"guides/realtime/","text":"TBD","title":"Realtime API"},{"location":"guides/run-context/","text":"RunContext carries application data through a run, controls tool approvals, and tracks usage. It is the shared state object that tools, guardrails, and the runner can read and update. Overview RunContext is used for: Application data : user, session, org, feature flags, service clients, etc. Tool approvals : allow or block tool calls per-call or permanently. Usage tracking : accumulate token usage across turns and across runs. If you do not supply a RunContext, the runner creates one with UnknownContext . Create and Pass a RunContext Default (UnknownContext) RunContext < UnknownContext > context = new RunContext <> (); RunConfig config = RunConfig . builder (). context ( java . util . Optional . of ( context )). build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" , config ); Custom Context Data public class AppContext { String userId ; String sessionId ; boolean premiumUser ; } AppContext appContext = new AppContext (); appContext . userId = \"user_123\" ; appContext . sessionId = \"session_456\" ; appContext . premiumUser = true ; RunContext < AppContext > context = new RunContext <> ( appContext ); RunConfig config = RunConfig . builder (). context ( java . util . Optional . of ( context )). build (); RunResult < AppContext , ?> result = Runner . run ( agent , \"Your prompt\" , config ); Access Context in Tools Every tool receives the RunContext: public class DatabaseTool implements FunctionTool < AppContext , Input , Output > { @Override public CompletableFuture < Output > invoke ( RunContext < AppContext > context , Input input ) { AppContext appContext = context . getContext (); if ( ! appContext . premiumUser ) { return CompletableFuture . completedFuture ( new Output ( \"Upgrade required.\" )); } return performDatabaseQuery ( appContext . userId , input ); } } View complete example \u2192 Tool Approval System Approval is tri-state: true = approved false = rejected null = pending decision Per-Call Approval RunContext < UnknownContext > context = new RunContext <> (); RunToolApprovalItem approval = RunToolApprovalItem . builder () . toolName ( \"send_email\" ) . toolCallId ( \"call_123\" ) . build (); context . approveTool ( approval ); Boolean approved = context . isToolApproved ( \"send_email\" , \"call_123\" ); // true Boolean other = context . isToolApproved ( \"send_email\" , \"call_456\" ); // null Permanent Approval RunToolApprovalItem approval = RunToolApprovalItem . builder () . toolName ( \"send_email\" ) . toolCallId ( \"call_123\" ) . build (); context . approveTool ( approval , true ); context . isToolApproved ( \"send_email\" , \"call_123\" ); // true context . isToolApproved ( \"send_email\" , \"call_456\" ); // true Rejection (Per-Call or Permanent) RunToolApprovalItem rejection = RunToolApprovalItem . builder () . toolName ( \"delete_data\" ) . toolCallId ( \"call_999\" ) . build (); context . rejectTool ( rejection , true ); context . isToolApproved ( \"delete_data\" , \"call_999\" ); // false Enforcing Approval in Tools Tools declare approval needs with needsApproval() : public class SensitiveTool implements FunctionTool < AppContext , Input , Output > { @Override public boolean needsApproval ( RunContext < AppContext > context , Input input ) { return input . getOperation (). equals ( \"delete\" ); } } When needsApproval() returns true , the runner checks context.isToolApproved(toolName, toolCallId) before executing the tool. Mixed Approval Modes RunContext < UnknownContext > context = new RunContext <> (); context . approveTool ( RunToolApprovalItem . builder (). toolName ( \"calculator\" ). toolCallId ( \"calc_001\" ). build (), true ); context . approveTool ( RunToolApprovalItem . builder (). toolName ( \"send_email\" ). toolCallId ( \"email_001\" ). build (), false ); context . rejectTool ( RunToolApprovalItem . builder (). toolName ( \"delete_file\" ). toolCallId ( \"delete_001\" ). build (), true ); Usage Tracking When you pass a RunContext via RunConfig, the runner accumulates usage automatically for each model response. Use addUsage() only if you are aggregating usage from other sources or runs. RunContext < UnknownContext > context = new RunContext <> (); context . addUsage ( Usage . builder (). inputTokens ( 100.0 ). outputTokens ( 50.0 ). totalTokens ( 150.0 ). build ()); context . addUsage ( Usage . builder (). inputTokens ( 200.0 ). outputTokens ( 75.0 ). totalTokens ( 275.0 ). build ()); Usage total = context . getUsage (); System . out . println ( \"Total tokens: \" + total . getTotalTokens ()); Serialization and Restore RunContext can serialize to a map for storage or debugging: RunContext < AppContext > context = new RunContext <> ( appContext ); context . addUsage ( Usage . builder (). totalTokens ( 500.0 ). build ()); Map < String , Object > json = context . toJSON (); To restore approvals from stored state, use rebuildApprovals() : RunContext < AppContext > restored = new RunContext <> ( appContext ); restored . rebuildApprovals ( savedApprovals ); Combine Context with Sessions Context and sessions solve different problems: context is app data and approvals, session is conversation memory. Use both via RunConfig: RunContext < AppContext > context = new RunContext <> ( appContext ); Session session = new MemorySession ( \"conversation_123\" ); RunConfig config = RunConfig . builder () . context ( java . util . Optional . of ( context )) . session ( session ) . build (); RunResult < AppContext , ?> result = Runner . run ( agent , \"My name is Alice\" , config ); Advanced Patterns Dynamic Approval Based on Input @Override public boolean needsApproval ( RunContext < AppContext > context , Input input ) { if ( input . getAmount () < 10.0 ) { return false ; } if ( input . getAmount () > 1000.0 ) { return true ; } return ! context . getContext (). isPreApproved ( input . getOperation ()); } Budget Enforcement public class BudgetContext { double budget ; double spent ; boolean canSpend ( double amount ) { return ( spent + amount ) <= budget ; } } @Override public boolean needsApproval ( RunContext < BudgetContext > context , Input input ) { return ! context . getContext (). canSpend ( input . getAmount ()); } Approval Chains @Override public boolean needsApproval ( RunContext < AppContext > context , Input input ) { AppContext appContext = context . getContext (); if ( \"admin\" . equals ( appContext . getUserRole ())) { return false ; } if ( appContext . hasPermission ( input . getOperation ())) { return false ; } return input . getAmount () >= appContext . getApprovalThreshold (); } Example Index The RunContextExample covers: Basic context storage Usage tracking Per-call tool approvals Permanent tool approvals Tool rejection Mixed approval modes Serialization Real-World Example RealWorldRunContextExample.java \u2192 Best Practices Keep context small and focused on app data and approvals. Prefer immutable data where possible, or document ownership clearly. Use per-call approval for sensitive tools; permanent approval for safe tools. Avoid double-counting usage if the runner already tracks it. Make context serializable if you need persistence across requests. Next Steps Tools - Implement tools that use context Handoffs - Pass context across agent handoffs Sessions - Combine context with conversation memory Guardrails - Add safety constraints using context","title":"Run Context"},{"location":"guides/run-context/#overview","text":"RunContext is used for: Application data : user, session, org, feature flags, service clients, etc. Tool approvals : allow or block tool calls per-call or permanently. Usage tracking : accumulate token usage across turns and across runs. If you do not supply a RunContext, the runner creates one with UnknownContext .","title":"Overview"},{"location":"guides/run-context/#create-and-pass-a-runcontext","text":"","title":"Create and Pass a RunContext"},{"location":"guides/run-context/#default-unknowncontext","text":"RunContext < UnknownContext > context = new RunContext <> (); RunConfig config = RunConfig . builder (). context ( java . util . Optional . of ( context )). build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" , config );","title":"Default (UnknownContext)"},{"location":"guides/run-context/#custom-context-data","text":"public class AppContext { String userId ; String sessionId ; boolean premiumUser ; } AppContext appContext = new AppContext (); appContext . userId = \"user_123\" ; appContext . sessionId = \"session_456\" ; appContext . premiumUser = true ; RunContext < AppContext > context = new RunContext <> ( appContext ); RunConfig config = RunConfig . builder (). context ( java . util . Optional . of ( context )). build (); RunResult < AppContext , ?> result = Runner . run ( agent , \"Your prompt\" , config );","title":"Custom Context Data"},{"location":"guides/run-context/#access-context-in-tools","text":"Every tool receives the RunContext: public class DatabaseTool implements FunctionTool < AppContext , Input , Output > { @Override public CompletableFuture < Output > invoke ( RunContext < AppContext > context , Input input ) { AppContext appContext = context . getContext (); if ( ! appContext . premiumUser ) { return CompletableFuture . completedFuture ( new Output ( \"Upgrade required.\" )); } return performDatabaseQuery ( appContext . userId , input ); } } View complete example \u2192","title":"Access Context in Tools"},{"location":"guides/run-context/#tool-approval-system","text":"Approval is tri-state: true = approved false = rejected null = pending decision","title":"Tool Approval System"},{"location":"guides/run-context/#per-call-approval","text":"RunContext < UnknownContext > context = new RunContext <> (); RunToolApprovalItem approval = RunToolApprovalItem . builder () . toolName ( \"send_email\" ) . toolCallId ( \"call_123\" ) . build (); context . approveTool ( approval ); Boolean approved = context . isToolApproved ( \"send_email\" , \"call_123\" ); // true Boolean other = context . isToolApproved ( \"send_email\" , \"call_456\" ); // null","title":"Per-Call Approval"},{"location":"guides/run-context/#permanent-approval","text":"RunToolApprovalItem approval = RunToolApprovalItem . builder () . toolName ( \"send_email\" ) . toolCallId ( \"call_123\" ) . build (); context . approveTool ( approval , true ); context . isToolApproved ( \"send_email\" , \"call_123\" ); // true context . isToolApproved ( \"send_email\" , \"call_456\" ); // true","title":"Permanent Approval"},{"location":"guides/run-context/#rejection-per-call-or-permanent","text":"RunToolApprovalItem rejection = RunToolApprovalItem . builder () . toolName ( \"delete_data\" ) . toolCallId ( \"call_999\" ) . build (); context . rejectTool ( rejection , true ); context . isToolApproved ( \"delete_data\" , \"call_999\" ); // false","title":"Rejection (Per-Call or Permanent)"},{"location":"guides/run-context/#enforcing-approval-in-tools","text":"Tools declare approval needs with needsApproval() : public class SensitiveTool implements FunctionTool < AppContext , Input , Output > { @Override public boolean needsApproval ( RunContext < AppContext > context , Input input ) { return input . getOperation (). equals ( \"delete\" ); } } When needsApproval() returns true , the runner checks context.isToolApproved(toolName, toolCallId) before executing the tool.","title":"Enforcing Approval in Tools"},{"location":"guides/run-context/#mixed-approval-modes","text":"RunContext < UnknownContext > context = new RunContext <> (); context . approveTool ( RunToolApprovalItem . builder (). toolName ( \"calculator\" ). toolCallId ( \"calc_001\" ). build (), true ); context . approveTool ( RunToolApprovalItem . builder (). toolName ( \"send_email\" ). toolCallId ( \"email_001\" ). build (), false ); context . rejectTool ( RunToolApprovalItem . builder (). toolName ( \"delete_file\" ). toolCallId ( \"delete_001\" ). build (), true );","title":"Mixed Approval Modes"},{"location":"guides/run-context/#usage-tracking","text":"When you pass a RunContext via RunConfig, the runner accumulates usage automatically for each model response. Use addUsage() only if you are aggregating usage from other sources or runs. RunContext < UnknownContext > context = new RunContext <> (); context . addUsage ( Usage . builder (). inputTokens ( 100.0 ). outputTokens ( 50.0 ). totalTokens ( 150.0 ). build ()); context . addUsage ( Usage . builder (). inputTokens ( 200.0 ). outputTokens ( 75.0 ). totalTokens ( 275.0 ). build ()); Usage total = context . getUsage (); System . out . println ( \"Total tokens: \" + total . getTotalTokens ());","title":"Usage Tracking"},{"location":"guides/run-context/#serialization-and-restore","text":"RunContext can serialize to a map for storage or debugging: RunContext < AppContext > context = new RunContext <> ( appContext ); context . addUsage ( Usage . builder (). totalTokens ( 500.0 ). build ()); Map < String , Object > json = context . toJSON (); To restore approvals from stored state, use rebuildApprovals() : RunContext < AppContext > restored = new RunContext <> ( appContext ); restored . rebuildApprovals ( savedApprovals );","title":"Serialization and Restore"},{"location":"guides/run-context/#combine-context-with-sessions","text":"Context and sessions solve different problems: context is app data and approvals, session is conversation memory. Use both via RunConfig: RunContext < AppContext > context = new RunContext <> ( appContext ); Session session = new MemorySession ( \"conversation_123\" ); RunConfig config = RunConfig . builder () . context ( java . util . Optional . of ( context )) . session ( session ) . build (); RunResult < AppContext , ?> result = Runner . run ( agent , \"My name is Alice\" , config );","title":"Combine Context with Sessions"},{"location":"guides/run-context/#advanced-patterns","text":"","title":"Advanced Patterns"},{"location":"guides/run-context/#dynamic-approval-based-on-input","text":"@Override public boolean needsApproval ( RunContext < AppContext > context , Input input ) { if ( input . getAmount () < 10.0 ) { return false ; } if ( input . getAmount () > 1000.0 ) { return true ; } return ! context . getContext (). isPreApproved ( input . getOperation ()); }","title":"Dynamic Approval Based on Input"},{"location":"guides/run-context/#budget-enforcement","text":"public class BudgetContext { double budget ; double spent ; boolean canSpend ( double amount ) { return ( spent + amount ) <= budget ; } } @Override public boolean needsApproval ( RunContext < BudgetContext > context , Input input ) { return ! context . getContext (). canSpend ( input . getAmount ()); }","title":"Budget Enforcement"},{"location":"guides/run-context/#approval-chains","text":"@Override public boolean needsApproval ( RunContext < AppContext > context , Input input ) { AppContext appContext = context . getContext (); if ( \"admin\" . equals ( appContext . getUserRole ())) { return false ; } if ( appContext . hasPermission ( input . getOperation ())) { return false ; } return input . getAmount () >= appContext . getApprovalThreshold (); }","title":"Approval Chains"},{"location":"guides/run-context/#example-index","text":"The RunContextExample covers: Basic context storage Usage tracking Per-call tool approvals Permanent tool approvals Tool rejection Mixed approval modes Serialization","title":"Example Index"},{"location":"guides/run-context/#real-world-example","text":"RealWorldRunContextExample.java \u2192","title":"Real-World Example"},{"location":"guides/run-context/#best-practices","text":"Keep context small and focused on app data and approvals. Prefer immutable data where possible, or document ownership clearly. Use per-call approval for sensitive tools; permanent approval for safe tools. Avoid double-counting usage if the runner already tracks it. Make context serializable if you need persistence across requests.","title":"Best Practices"},{"location":"guides/run-context/#next-steps","text":"Tools - Implement tools that use context Handoffs - Pass context across agent handoffs Sessions - Combine context with conversation memory Guardrails - Add safety constraints using context","title":"Next Steps"},{"location":"guides/running-agents/","text":"Learn how to execute agents and handle results. Overview The Runner class provides static methods for executing agents synchronously, asynchronously, or with streaming. Each execution returns a RunResult containing the output, usage statistics, and execution metadata. Basic Execution Execute an agent with a simple text prompt: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Explain what an AI agent is in one sentence.\" ); System . out . println ( result . getFinalOutput ()); // Output: \"An AI agent is a software system...\" View complete example \u2192 Runner Methods Runner.run() Synchronous execution that blocks until completion: RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" ); With configuration: RunConfig config = RunConfig . builder () . maxTurns ( 10 ) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" , config ); Runner.runAsync() Asynchronous execution returning a CompletableFuture : CompletableFuture < RunResult < UnknownContext , ?>> futureResult = Runner . runAsync ( agent , \"Your prompt\" ); // Process result when ready futureResult . thenAccept ( result -> { System . out . println ( result . getFinalOutput ()); }); Runner.runStreamed() Streaming execution for real-time updates: Flux < RunStreamEvent > stream = Runner . runStreamed ( agent , \"Your prompt\" ); stream . subscribe ( event -> { if ( event . getEventType (). equals ( \"output\" )) { System . out . print ( event . getData ()); } }); See the Streaming guide for detailed streaming patterns. Run Configuration Configure execution behavior with RunConfig : RunConfig config = RunConfig . builder () . maxTurns ( 5 ) // Maximum conversation turns (default: 20) . timeout ( 30000 ) // Timeout in milliseconds . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" , config ); Configuration Options Option Type Default Description maxTurns int 20 Maximum number of conversation turns before stopping timeout long None Maximum execution time in milliseconds Max Turns Limit When the agent reaches maxTurns , execution stops and may throw MaxTurnsExceededError . Set this value based on your task complexity and cost tolerance. Understanding RunResult RunResult contains comprehensive information about the agent execution: RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your question\" ); // Final output Object output = result . getFinalOutput (); // Usage statistics Usage usage = result . getUsage (); System . out . println ( \"Total tokens: \" + usage . getTotalTokens ()); System . out . println ( \"Input tokens: \" + usage . getInputTokens ()); System . out . println ( \"Output tokens: \" + usage . getOutputTokens ()); // Execution metadata List < ModelResponse > responses = result . getRawResponses (); System . out . println ( \"Turns taken: \" + responses . size ()); List < RunOutputItem > items = result . getNewItems (); String lastId = result . getLastResponseId (); RunResult Methods Method Return Type Description getFinalOutput() Object The agent's final output (text or structured) getUsage() Usage Token usage statistics getRawResponses() List<ModelResponse> All model responses (one per turn) getNewItems() List<RunOutputItem> Generated conversation items getLastResponseId() String ID of the last response Multi-Turn Execution Agents may require multiple turns to complete complex tasks, especially when using tools: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"ThinkingAssistant\" ) . instructions ( \"Think step by step to provide thorough answers.\" ) . build (); RunConfig config = RunConfig . builder () . maxTurns ( 5 ) // Allow up to 5 turns . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What are the key differences between OOP and functional programming?\" , config ); // Track execution System . out . println ( \"Turns taken: \" + result . getRawResponses (). size ()); System . out . println ( \"Total tokens: \" + result . getUsage (). getTotalTokens ()); Each turn represents one request-response cycle with the model. Multi-turn execution occurs when: The agent calls tools and processes their results The agent uses handoffs to delegate to other agents The agent performs multi-step reasoning View complete example \u2192 Per-Turn Usage Tracking Track token usage for each individual turn: RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your question\" ); // Per-turn breakdown int turnNumber = 1 ; for ( ModelResponse response : result . getRawResponses ()) { System . out . printf ( \"Turn %d: %.0f tokens (in: %.0f, out: %.0f)%n\" , turnNumber , response . getUsage (). getTotalTokens (), response . getUsage (). getInputTokens (), response . getUsage (). getOutputTokens () ); turnNumber ++ ; } Error Handling Handle common execution errors: try { RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" ); System . out . println ( result . getFinalOutput ()); } catch ( MaxTurnsExceededError e ) { // Agent hit the max turns limit System . err . println ( \"Agent exceeded maximum turns: \" + e . getMessage ()); } catch ( AuthenticationException e ) { // Invalid or missing API key System . err . println ( \"Authentication failed: \" + e . getMessage ()); System . err . println ( \"Check your OPENAI_API_KEY environment variable\" ); } catch ( RateLimitException e ) { // Hit OpenAI rate limits System . err . println ( \"Rate limit exceeded: \" + e . getMessage ()); System . err . println ( \"Retry after: \" + e . getRetryAfter ()); } catch ( Exception e ) { // Other errors (network, model errors, etc.) System . err . println ( \"Execution failed: \" + e . getMessage ()); } Common Error Types Exception Cause Resolution MaxTurnsExceededError Agent hit maxTurns limit Increase maxTurns or simplify the task AuthenticationException Invalid/missing API key Set OPENAI_API_KEY environment variable RateLimitException Hit OpenAI rate limits Implement retry logic with backoff TimeoutException Execution exceeded timeout Increase timeout or simplify task Production Error Handling Always implement retry logic with exponential backoff for rate limit and network errors. Use structured logging to track execution failures. Running with Sessions Add conversation memory using sessions: // Create a session for conversation memory Session session = new MemorySession (); Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . build (); // First message RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"My name is Alice\" , session ); // Agent remembers previous context RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"What's my name?\" , session ); System . out . println ( result2 . getFinalOutput ()); // Output: \"Your name is Alice.\" See the Sessions guide for detailed session management. Running with Context Pass custom context for tool approval or usage tracking: public class MyContext { private Set < String > approvedActions = new HashSet <> (); public void approve ( String action ) { approvedActions . add ( action ); } public boolean isApproved ( String action ) { return approvedActions . contains ( action ); } } Agent < MyContext , TextOutput > agent = /* ... */ ; MyContext context = new MyContext (); RunResult < MyContext , ?> result = Runner . run ( agent , \"Your prompt\" , context ); See the Run Context guide for advanced context patterns. Best Practices Optimize Token Usage Monitor result.getUsage() to track costs Use gpt-4.1-mini for simple tasks to reduce costs Set appropriate maxTurns to prevent runaway executions Use sessions to maintain context without repeating information Error Recovery Implement exponential backoff for rate limit errors Log lastResponseId for debugging partial failures Set reasonable timeouts for production workloads Validate inputs before execution to fail fast Performance Use runAsync() for non-blocking operations Use streaming for real-time user feedback Cache frequently used agents (they're immutable and thread-safe) Pool session objects for concurrent executions Next Steps Streaming - Real-time output streaming Tools - Add custom functions for agents to call Sessions - Add conversation memory Run Context - Custom context and tool approval Additional Resources BasicTextOutput.java - Simple execution MultiTurnExecution.java - Multi-turn tracking API Reference - Complete Javadoc documentation","title":"Running Agents"},{"location":"guides/running-agents/#overview","text":"The Runner class provides static methods for executing agents synchronously, asynchronously, or with streaming. Each execution returns a RunResult containing the output, usage statistics, and execution metadata.","title":"Overview"},{"location":"guides/running-agents/#basic-execution","text":"Execute an agent with a simple text prompt: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Explain what an AI agent is in one sentence.\" ); System . out . println ( result . getFinalOutput ()); // Output: \"An AI agent is a software system...\" View complete example \u2192","title":"Basic Execution"},{"location":"guides/running-agents/#runner-methods","text":"","title":"Runner Methods"},{"location":"guides/running-agents/#runnerrun","text":"Synchronous execution that blocks until completion: RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" ); With configuration: RunConfig config = RunConfig . builder () . maxTurns ( 10 ) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" , config );","title":"Runner.run()"},{"location":"guides/running-agents/#runnerrunasync","text":"Asynchronous execution returning a CompletableFuture : CompletableFuture < RunResult < UnknownContext , ?>> futureResult = Runner . runAsync ( agent , \"Your prompt\" ); // Process result when ready futureResult . thenAccept ( result -> { System . out . println ( result . getFinalOutput ()); });","title":"Runner.runAsync()"},{"location":"guides/running-agents/#runnerrunstreamed","text":"Streaming execution for real-time updates: Flux < RunStreamEvent > stream = Runner . runStreamed ( agent , \"Your prompt\" ); stream . subscribe ( event -> { if ( event . getEventType (). equals ( \"output\" )) { System . out . print ( event . getData ()); } }); See the Streaming guide for detailed streaming patterns.","title":"Runner.runStreamed()"},{"location":"guides/running-agents/#run-configuration","text":"Configure execution behavior with RunConfig : RunConfig config = RunConfig . builder () . maxTurns ( 5 ) // Maximum conversation turns (default: 20) . timeout ( 30000 ) // Timeout in milliseconds . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" , config );","title":"Run Configuration"},{"location":"guides/running-agents/#configuration-options","text":"Option Type Default Description maxTurns int 20 Maximum number of conversation turns before stopping timeout long None Maximum execution time in milliseconds Max Turns Limit When the agent reaches maxTurns , execution stops and may throw MaxTurnsExceededError . Set this value based on your task complexity and cost tolerance.","title":"Configuration Options"},{"location":"guides/running-agents/#understanding-runresult","text":"RunResult contains comprehensive information about the agent execution: RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your question\" ); // Final output Object output = result . getFinalOutput (); // Usage statistics Usage usage = result . getUsage (); System . out . println ( \"Total tokens: \" + usage . getTotalTokens ()); System . out . println ( \"Input tokens: \" + usage . getInputTokens ()); System . out . println ( \"Output tokens: \" + usage . getOutputTokens ()); // Execution metadata List < ModelResponse > responses = result . getRawResponses (); System . out . println ( \"Turns taken: \" + responses . size ()); List < RunOutputItem > items = result . getNewItems (); String lastId = result . getLastResponseId ();","title":"Understanding RunResult"},{"location":"guides/running-agents/#runresult-methods","text":"Method Return Type Description getFinalOutput() Object The agent's final output (text or structured) getUsage() Usage Token usage statistics getRawResponses() List<ModelResponse> All model responses (one per turn) getNewItems() List<RunOutputItem> Generated conversation items getLastResponseId() String ID of the last response","title":"RunResult Methods"},{"location":"guides/running-agents/#multi-turn-execution","text":"Agents may require multiple turns to complete complex tasks, especially when using tools: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"ThinkingAssistant\" ) . instructions ( \"Think step by step to provide thorough answers.\" ) . build (); RunConfig config = RunConfig . builder () . maxTurns ( 5 ) // Allow up to 5 turns . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What are the key differences between OOP and functional programming?\" , config ); // Track execution System . out . println ( \"Turns taken: \" + result . getRawResponses (). size ()); System . out . println ( \"Total tokens: \" + result . getUsage (). getTotalTokens ()); Each turn represents one request-response cycle with the model. Multi-turn execution occurs when: The agent calls tools and processes their results The agent uses handoffs to delegate to other agents The agent performs multi-step reasoning View complete example \u2192","title":"Multi-Turn Execution"},{"location":"guides/running-agents/#per-turn-usage-tracking","text":"Track token usage for each individual turn: RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your question\" ); // Per-turn breakdown int turnNumber = 1 ; for ( ModelResponse response : result . getRawResponses ()) { System . out . printf ( \"Turn %d: %.0f tokens (in: %.0f, out: %.0f)%n\" , turnNumber , response . getUsage (). getTotalTokens (), response . getUsage (). getInputTokens (), response . getUsage (). getOutputTokens () ); turnNumber ++ ; }","title":"Per-Turn Usage Tracking"},{"location":"guides/running-agents/#error-handling","text":"Handle common execution errors: try { RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Your prompt\" ); System . out . println ( result . getFinalOutput ()); } catch ( MaxTurnsExceededError e ) { // Agent hit the max turns limit System . err . println ( \"Agent exceeded maximum turns: \" + e . getMessage ()); } catch ( AuthenticationException e ) { // Invalid or missing API key System . err . println ( \"Authentication failed: \" + e . getMessage ()); System . err . println ( \"Check your OPENAI_API_KEY environment variable\" ); } catch ( RateLimitException e ) { // Hit OpenAI rate limits System . err . println ( \"Rate limit exceeded: \" + e . getMessage ()); System . err . println ( \"Retry after: \" + e . getRetryAfter ()); } catch ( Exception e ) { // Other errors (network, model errors, etc.) System . err . println ( \"Execution failed: \" + e . getMessage ()); }","title":"Error Handling"},{"location":"guides/running-agents/#common-error-types","text":"Exception Cause Resolution MaxTurnsExceededError Agent hit maxTurns limit Increase maxTurns or simplify the task AuthenticationException Invalid/missing API key Set OPENAI_API_KEY environment variable RateLimitException Hit OpenAI rate limits Implement retry logic with backoff TimeoutException Execution exceeded timeout Increase timeout or simplify task Production Error Handling Always implement retry logic with exponential backoff for rate limit and network errors. Use structured logging to track execution failures.","title":"Common Error Types"},{"location":"guides/running-agents/#running-with-sessions","text":"Add conversation memory using sessions: // Create a session for conversation memory Session session = new MemorySession (); Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant.\" ) . build (); // First message RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"My name is Alice\" , session ); // Agent remembers previous context RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"What's my name?\" , session ); System . out . println ( result2 . getFinalOutput ()); // Output: \"Your name is Alice.\" See the Sessions guide for detailed session management.","title":"Running with Sessions"},{"location":"guides/running-agents/#running-with-context","text":"Pass custom context for tool approval or usage tracking: public class MyContext { private Set < String > approvedActions = new HashSet <> (); public void approve ( String action ) { approvedActions . add ( action ); } public boolean isApproved ( String action ) { return approvedActions . contains ( action ); } } Agent < MyContext , TextOutput > agent = /* ... */ ; MyContext context = new MyContext (); RunResult < MyContext , ?> result = Runner . run ( agent , \"Your prompt\" , context ); See the Run Context guide for advanced context patterns.","title":"Running with Context"},{"location":"guides/running-agents/#best-practices","text":"Optimize Token Usage Monitor result.getUsage() to track costs Use gpt-4.1-mini for simple tasks to reduce costs Set appropriate maxTurns to prevent runaway executions Use sessions to maintain context without repeating information Error Recovery Implement exponential backoff for rate limit errors Log lastResponseId for debugging partial failures Set reasonable timeouts for production workloads Validate inputs before execution to fail fast Performance Use runAsync() for non-blocking operations Use streaming for real-time user feedback Cache frequently used agents (they're immutable and thread-safe) Pool session objects for concurrent executions","title":"Best Practices"},{"location":"guides/running-agents/#next-steps","text":"Streaming - Real-time output streaming Tools - Add custom functions for agents to call Sessions - Add conversation memory Run Context - Custom context and tool approval","title":"Next Steps"},{"location":"guides/running-agents/#additional-resources","text":"BasicTextOutput.java - Simple execution MultiTurnExecution.java - Multi-turn tracking API Reference - Complete Javadoc documentation","title":"Additional Resources"},{"location":"guides/sessions/","text":"Add conversation memory so agents remember previous interactions. Overview Sessions store conversation history across multiple agent runs. Without sessions, each run starts with no context. With sessions, agents remember previous messages, creating coherent multi-turn conversations. Two session implementations: MemorySession : In-memory storage for development and testing SQLiteSession : Persistent SQLite storage for production Basic Session Usage Create a session and pass it via RunConfig : // Create a simple agent Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant with a good memory.\" ) . build (); // Create an in-memory session Session session = new MemorySession ( \"conversation-123\" ); // Create RunConfig with the session RunConfig config = RunConfig . builder (). session ( session ). build (); // Turn 1 RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"My name is Alice and I love hiking.\" , config ); // Turn 2 - agent remembers Alice RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"What's my name?\" , config ); System . out . println ( result2 . getFinalOutput ()); // Output: \"Your name is Alice.\" The session automatically stores all messages and tool calls, maintaining full conversation context. MemorySession In-memory session for development and short-lived conversations. Creating a MemorySession // Create with explicit session ID Session session = new MemorySession ( \"conversation-123\" ); // Or generate random ID Session session = new MemorySession (); When to Use MemorySession Use for: Development and testing Short-lived conversations (single request lifecycle) Prototyping and experimentation Applications where persistence isn't needed Don't use for: Production applications requiring persistence Long-running conversations Multi-instance deployments Conversations that must survive restarts Example: Multi-Turn Conversation Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"Remember details from the conversation naturally.\" ) . build (); Session session = new MemorySession ( \"user-session\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // Turn 1: User introduces themselves RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"My name is Alice and I love hiking.\" , config ); System . out . println ( \"Agent: \" + result1 . getFinalOutput ()); // Turn 2: Ask unrelated question RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"What's the capital of France?\" , config ); System . out . println ( \"Agent: \" + result2 . getFinalOutput ()); // Turn 3: Agent remembers name RunResult < UnknownContext , ?> result3 = Runner . run ( agent , \"What's my name?\" , config ); System . out . println ( \"Agent: \" + result3 . getFinalOutput ()); // Output: \"Your name is Alice.\" // Turn 4: Agent remembers hobby RunResult < UnknownContext , ?> result4 = Runner . run ( agent , \"What hobby did I mention?\" , config ); System . out . println ( \"Agent: \" + result4 . getFinalOutput ()); // Output: \"You mentioned that you love hiking.\" // Session statistics System . out . println ( \"Total items in history: \" + session . getItems ( null ). join (). size ()); View complete example \u2192 Data Loss MemorySession data is lost when the JVM exits. Use SQLiteSession for persistence. SQLiteSession Persistent session storage using SQLite database. Creating a SQLiteSession Path dbPath = Path . of ( \"./conversations.db\" ); String sessionId = \"alice-conversation\" ; // Create or open SQLite session try ( SQLiteSession session = SQLiteSession . fromFile ( sessionId , dbPath )) { // Use session... } The database file is created automatically if it doesn't exist. When to Use SQLiteSession Use for: Production applications requiring persistence Long-running conversations Multi-session management (multiple users/conversations) Conversation history across application restarts Audit trails and conversation analysis Features: WAL mode for better concurrency Session isolation (multiple sessions in one database) Transaction support for data integrity Automatic schema management Example: Persistent Conversations Path dbPath = Path . of ( \"./example-conversations.db\" ); String sessionId = \"alice-conversation\" ; Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"PersistentAssistant\" ) . instructions ( \"Remember all details from previous conversations.\" ) . build (); try ( SQLiteSession session = SQLiteSession . fromFile ( sessionId , dbPath )) { // Check existing history List < AgentInputItem > existingHistory = session . getItems ( null ). join (); if ( ! existingHistory . isEmpty ()) { System . out . println ( \"Found \" + existingHistory . size () + \" items in conversation history\" ); System . out . println ( \"This is a continuation of a previous conversation.\" ); } // Create RunConfig with the session RunConfig config = RunConfig . builder (). session ( session ). build (); if ( existingHistory . isEmpty ()) { // First conversation System . out . println ( \"Turn 1:\" ); RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"Hi! My name is Alice, I'm a software engineer, and I love rock climbing.\" , config ); System . out . println ( \"Agent: \" + result1 . getFinalOutput ()); System . out . println ( \"\\nTurn 2:\" ); RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"I work mostly with Java and Python.\" , config ); System . out . println ( \"Agent: \" + result2 . getFinalOutput ()); System . out . println ( \"\\nRun this example again to see persistence!\" ); } else { // Continuation - test memory System . out . println ( \"Turn 1 (testing memory):\" ); RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"Hi again! Do you remember me?\" , config ); System . out . println ( \"Agent: \" + result1 . getFinalOutput ()); System . out . println ( \"\\nTurn 2:\" ); RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"What programming languages do I use?\" , config ); System . out . println ( \"Agent: \" + result2 . getFinalOutput ()); // Output: \"You mentioned that you work with Java and Python.\" } System . out . println ( \"\\nTotal items in history: \" + session . getItems ( null ). join (). size ()); } Run this example multiple times - the agent remembers details across program executions. View complete example \u2192 Session Operations Both session types implement the Session interface: Get Session ID CompletableFuture < String > sessionIdFuture = session . getSessionId (); String sessionId = sessionIdFuture . join (); Get Conversation History // Get all items CompletableFuture < List < AgentInputItem >> itemsFuture = session . getItems ( null ); List < AgentInputItem > items = itemsFuture . join (); System . out . println ( \"Total items: \" + items . size ()); Add Items Manually // Create a message item AgentInputItem message = /* ... */ ; // Add to session session . addItems ( List . of ( message )). join (); Remove Last Item // Remove the most recent item session . popItem (). join (); Clear Session // Clear all conversation history session . clearSession (). join (); Sessions with Tools Sessions store tool calls and results, maintaining full execution context: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"Use tools to help answer questions.\" ) . tools ( List . of ( new CalculatorTool (), new WeatherTool ())) . build (); Session session = new MemorySession ( \"tool-conversation\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // Turn 1: Agent uses calculator RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"What is 25 * 17?\" , config ); System . out . println ( result1 . getFinalOutput ()); // Turn 2: Agent references previous calculation RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"Double that number\" , config ); System . out . println ( result2 . getFinalOutput ()); // Agent remembers the result (425) and calculates 425 * 2 = 850 Tool calls, inputs, and outputs are all stored in the session. Sessions with Handoffs Sessions preserve context across agent handoffs: Agent < UnknownContext , TextOutput > billingAgent = /* ... */ ; Agent < UnknownContext , TextOutput > supportAgent = /* ... */ ; Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"Route to appropriate specialist.\" ) . handoffs ( List . of ( billingAgent , supportAgent )) . build (); Session session = new MemorySession ( \"customer-conversation\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // Turn 1: Routes to billing specialist RunResult < UnknownContext , ?> result1 = Runner . run ( triageAgent , \"I was charged incorrectly for my subscription.\" , config ); // Turn 2: Routes to support, but specialist sees full history RunResult < UnknownContext , ?> result2 = Runner . run ( triageAgent , \"Also, the app is crashing when I try to view my invoices.\" , config ); // Both specialists have access to full conversation history Specialists can reference earlier parts of the conversation, even from before the handoff. Managing Multiple Sessions Single Database, Multiple Sessions Path dbPath = Path . of ( \"./all-conversations.db\" ); // User 1's conversation try ( SQLiteSession session1 = SQLiteSession . fromFile ( \"user-alice\" , dbPath )) { RunConfig config1 = RunConfig . builder (). session ( session1 ). build (); Runner . run ( agent , \"Alice's question\" , config1 ); } // User 2's conversation (same database, different session) try ( SQLiteSession session2 = SQLiteSession . fromFile ( \"user-bob\" , dbPath )) { RunConfig config2 = RunConfig . builder (). session ( session2 ). build (); Runner . run ( agent , \"Bob's question\" , config2 ); } // Sessions are isolated - Alice and Bob have separate conversation histories Session Cleanup Delete old sessions to manage database size: try ( SQLiteSession session = SQLiteSession . fromFile ( sessionId , dbPath )) { // Clear conversation history session . clearSession (). join (); } // Or delete the entire database file Files . deleteIfExists ( dbPath ); Thread Safety Both MemorySession and SQLiteSession are thread-safe: Session session = new MemorySession ( \"shared-session\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // Safe to use from multiple threads ExecutorService executor = Executors . newFixedThreadPool ( 5 ); for ( int i = 0 ; i < 10 ; i ++ ) { int turnNumber = i ; executor . submit (() -> { RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Question \" + turnNumber , config ); System . out . println ( \"Turn \" + turnNumber + \": \" + result . getFinalOutput ()); }); } executor . shutdown (); SQLiteSession uses connection pooling and WAL mode for concurrent access. Best Practices Development vs Production Development : Use MemorySession for simplicity and speed Production : Use SQLiteSession for data persistence Testing : Use MemorySession for isolated test cases Long-Running : Use SQLiteSession for multi-day conversations Session Management Unique IDs : Use meaningful session IDs (user ID, conversation ID) Lifecycle : Match session lifecycle to conversation lifecycle Cleanup : Periodically clear old or abandoned sessions Size Monitoring : Monitor database size for long conversations Isolation : One session per conversation/user for clean separation Performance Connection Reuse : Reuse SQLiteSession instances when possible Batch Operations : Add multiple items at once when applicable Index Strategy : SQLiteSession automatically indexes session_id WAL Mode : SQLiteSession uses WAL mode for better concurrency History Limits : Consider truncating very long conversation histories Common Mistakes Sharing Sessions : Don't share sessions across unrelated conversations Missing try-with-resources : Always close SQLiteSession (use try-with-resources) Lost Context : Forgetting to pass session via RunConfig Memory Leaks : Not cleaning up MemorySession references File Permissions : Ensure write permissions for SQLiteSession database path Comparing Session Types Feature MemorySession SQLiteSession Persistence No (lost on exit) Yes (survives restarts) Performance Fast (in-memory) Good (disk I/O) Concurrency Thread-safe Thread-safe + WAL Storage Limit JVM memory Disk space Setup None required Database file Use Case Dev/testing Production Cleanup Automatic (GC) Manual Multi-session Separate instances Single database Next Steps Running Agents - Use RunConfig to pass sessions Handoffs - Maintain context across agent handoffs Run Context - Combine sessions with custom context Tools - Store tool interactions in sessions Additional Resources MemorySessionExample.java - In-memory session usage SQLiteSessionExample.java - Persistent storage API Reference - Complete Javadoc documentation","title":"Sessions"},{"location":"guides/sessions/#overview","text":"Sessions store conversation history across multiple agent runs. Without sessions, each run starts with no context. With sessions, agents remember previous messages, creating coherent multi-turn conversations. Two session implementations: MemorySession : In-memory storage for development and testing SQLiteSession : Persistent SQLite storage for production","title":"Overview"},{"location":"guides/sessions/#basic-session-usage","text":"Create a session and pass it via RunConfig : // Create a simple agent Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"You are a helpful assistant with a good memory.\" ) . build (); // Create an in-memory session Session session = new MemorySession ( \"conversation-123\" ); // Create RunConfig with the session RunConfig config = RunConfig . builder (). session ( session ). build (); // Turn 1 RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"My name is Alice and I love hiking.\" , config ); // Turn 2 - agent remembers Alice RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"What's my name?\" , config ); System . out . println ( result2 . getFinalOutput ()); // Output: \"Your name is Alice.\" The session automatically stores all messages and tool calls, maintaining full conversation context.","title":"Basic Session Usage"},{"location":"guides/sessions/#memorysession","text":"In-memory session for development and short-lived conversations.","title":"MemorySession"},{"location":"guides/sessions/#creating-a-memorysession","text":"// Create with explicit session ID Session session = new MemorySession ( \"conversation-123\" ); // Or generate random ID Session session = new MemorySession ();","title":"Creating a MemorySession"},{"location":"guides/sessions/#when-to-use-memorysession","text":"Use for: Development and testing Short-lived conversations (single request lifecycle) Prototyping and experimentation Applications where persistence isn't needed Don't use for: Production applications requiring persistence Long-running conversations Multi-instance deployments Conversations that must survive restarts","title":"When to Use MemorySession"},{"location":"guides/sessions/#example-multi-turn-conversation","text":"Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"Remember details from the conversation naturally.\" ) . build (); Session session = new MemorySession ( \"user-session\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // Turn 1: User introduces themselves RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"My name is Alice and I love hiking.\" , config ); System . out . println ( \"Agent: \" + result1 . getFinalOutput ()); // Turn 2: Ask unrelated question RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"What's the capital of France?\" , config ); System . out . println ( \"Agent: \" + result2 . getFinalOutput ()); // Turn 3: Agent remembers name RunResult < UnknownContext , ?> result3 = Runner . run ( agent , \"What's my name?\" , config ); System . out . println ( \"Agent: \" + result3 . getFinalOutput ()); // Output: \"Your name is Alice.\" // Turn 4: Agent remembers hobby RunResult < UnknownContext , ?> result4 = Runner . run ( agent , \"What hobby did I mention?\" , config ); System . out . println ( \"Agent: \" + result4 . getFinalOutput ()); // Output: \"You mentioned that you love hiking.\" // Session statistics System . out . println ( \"Total items in history: \" + session . getItems ( null ). join (). size ()); View complete example \u2192 Data Loss MemorySession data is lost when the JVM exits. Use SQLiteSession for persistence.","title":"Example: Multi-Turn Conversation"},{"location":"guides/sessions/#sqlitesession","text":"Persistent session storage using SQLite database.","title":"SQLiteSession"},{"location":"guides/sessions/#creating-a-sqlitesession","text":"Path dbPath = Path . of ( \"./conversations.db\" ); String sessionId = \"alice-conversation\" ; // Create or open SQLite session try ( SQLiteSession session = SQLiteSession . fromFile ( sessionId , dbPath )) { // Use session... } The database file is created automatically if it doesn't exist.","title":"Creating a SQLiteSession"},{"location":"guides/sessions/#when-to-use-sqlitesession","text":"Use for: Production applications requiring persistence Long-running conversations Multi-session management (multiple users/conversations) Conversation history across application restarts Audit trails and conversation analysis Features: WAL mode for better concurrency Session isolation (multiple sessions in one database) Transaction support for data integrity Automatic schema management","title":"When to Use SQLiteSession"},{"location":"guides/sessions/#example-persistent-conversations","text":"Path dbPath = Path . of ( \"./example-conversations.db\" ); String sessionId = \"alice-conversation\" ; Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"PersistentAssistant\" ) . instructions ( \"Remember all details from previous conversations.\" ) . build (); try ( SQLiteSession session = SQLiteSession . fromFile ( sessionId , dbPath )) { // Check existing history List < AgentInputItem > existingHistory = session . getItems ( null ). join (); if ( ! existingHistory . isEmpty ()) { System . out . println ( \"Found \" + existingHistory . size () + \" items in conversation history\" ); System . out . println ( \"This is a continuation of a previous conversation.\" ); } // Create RunConfig with the session RunConfig config = RunConfig . builder (). session ( session ). build (); if ( existingHistory . isEmpty ()) { // First conversation System . out . println ( \"Turn 1:\" ); RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"Hi! My name is Alice, I'm a software engineer, and I love rock climbing.\" , config ); System . out . println ( \"Agent: \" + result1 . getFinalOutput ()); System . out . println ( \"\\nTurn 2:\" ); RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"I work mostly with Java and Python.\" , config ); System . out . println ( \"Agent: \" + result2 . getFinalOutput ()); System . out . println ( \"\\nRun this example again to see persistence!\" ); } else { // Continuation - test memory System . out . println ( \"Turn 1 (testing memory):\" ); RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"Hi again! Do you remember me?\" , config ); System . out . println ( \"Agent: \" + result1 . getFinalOutput ()); System . out . println ( \"\\nTurn 2:\" ); RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"What programming languages do I use?\" , config ); System . out . println ( \"Agent: \" + result2 . getFinalOutput ()); // Output: \"You mentioned that you work with Java and Python.\" } System . out . println ( \"\\nTotal items in history: \" + session . getItems ( null ). join (). size ()); } Run this example multiple times - the agent remembers details across program executions. View complete example \u2192","title":"Example: Persistent Conversations"},{"location":"guides/sessions/#session-operations","text":"Both session types implement the Session interface:","title":"Session Operations"},{"location":"guides/sessions/#get-session-id","text":"CompletableFuture < String > sessionIdFuture = session . getSessionId (); String sessionId = sessionIdFuture . join ();","title":"Get Session ID"},{"location":"guides/sessions/#get-conversation-history","text":"// Get all items CompletableFuture < List < AgentInputItem >> itemsFuture = session . getItems ( null ); List < AgentInputItem > items = itemsFuture . join (); System . out . println ( \"Total items: \" + items . size ());","title":"Get Conversation History"},{"location":"guides/sessions/#add-items-manually","text":"// Create a message item AgentInputItem message = /* ... */ ; // Add to session session . addItems ( List . of ( message )). join ();","title":"Add Items Manually"},{"location":"guides/sessions/#remove-last-item","text":"// Remove the most recent item session . popItem (). join ();","title":"Remove Last Item"},{"location":"guides/sessions/#clear-session","text":"// Clear all conversation history session . clearSession (). join ();","title":"Clear Session"},{"location":"guides/sessions/#sessions-with-tools","text":"Sessions store tool calls and results, maintaining full execution context: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Assistant\" ) . instructions ( \"Use tools to help answer questions.\" ) . tools ( List . of ( new CalculatorTool (), new WeatherTool ())) . build (); Session session = new MemorySession ( \"tool-conversation\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // Turn 1: Agent uses calculator RunResult < UnknownContext , ?> result1 = Runner . run ( agent , \"What is 25 * 17?\" , config ); System . out . println ( result1 . getFinalOutput ()); // Turn 2: Agent references previous calculation RunResult < UnknownContext , ?> result2 = Runner . run ( agent , \"Double that number\" , config ); System . out . println ( result2 . getFinalOutput ()); // Agent remembers the result (425) and calculates 425 * 2 = 850 Tool calls, inputs, and outputs are all stored in the session.","title":"Sessions with Tools"},{"location":"guides/sessions/#sessions-with-handoffs","text":"Sessions preserve context across agent handoffs: Agent < UnknownContext , TextOutput > billingAgent = /* ... */ ; Agent < UnknownContext , TextOutput > supportAgent = /* ... */ ; Agent < UnknownContext , TextOutput > triageAgent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Triage\" ) . instructions ( \"Route to appropriate specialist.\" ) . handoffs ( List . of ( billingAgent , supportAgent )) . build (); Session session = new MemorySession ( \"customer-conversation\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // Turn 1: Routes to billing specialist RunResult < UnknownContext , ?> result1 = Runner . run ( triageAgent , \"I was charged incorrectly for my subscription.\" , config ); // Turn 2: Routes to support, but specialist sees full history RunResult < UnknownContext , ?> result2 = Runner . run ( triageAgent , \"Also, the app is crashing when I try to view my invoices.\" , config ); // Both specialists have access to full conversation history Specialists can reference earlier parts of the conversation, even from before the handoff.","title":"Sessions with Handoffs"},{"location":"guides/sessions/#managing-multiple-sessions","text":"","title":"Managing Multiple Sessions"},{"location":"guides/sessions/#single-database-multiple-sessions","text":"Path dbPath = Path . of ( \"./all-conversations.db\" ); // User 1's conversation try ( SQLiteSession session1 = SQLiteSession . fromFile ( \"user-alice\" , dbPath )) { RunConfig config1 = RunConfig . builder (). session ( session1 ). build (); Runner . run ( agent , \"Alice's question\" , config1 ); } // User 2's conversation (same database, different session) try ( SQLiteSession session2 = SQLiteSession . fromFile ( \"user-bob\" , dbPath )) { RunConfig config2 = RunConfig . builder (). session ( session2 ). build (); Runner . run ( agent , \"Bob's question\" , config2 ); } // Sessions are isolated - Alice and Bob have separate conversation histories","title":"Single Database, Multiple Sessions"},{"location":"guides/sessions/#session-cleanup","text":"Delete old sessions to manage database size: try ( SQLiteSession session = SQLiteSession . fromFile ( sessionId , dbPath )) { // Clear conversation history session . clearSession (). join (); } // Or delete the entire database file Files . deleteIfExists ( dbPath );","title":"Session Cleanup"},{"location":"guides/sessions/#thread-safety","text":"Both MemorySession and SQLiteSession are thread-safe: Session session = new MemorySession ( \"shared-session\" ); RunConfig config = RunConfig . builder (). session ( session ). build (); // Safe to use from multiple threads ExecutorService executor = Executors . newFixedThreadPool ( 5 ); for ( int i = 0 ; i < 10 ; i ++ ) { int turnNumber = i ; executor . submit (() -> { RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Question \" + turnNumber , config ); System . out . println ( \"Turn \" + turnNumber + \": \" + result . getFinalOutput ()); }); } executor . shutdown (); SQLiteSession uses connection pooling and WAL mode for concurrent access.","title":"Thread Safety"},{"location":"guides/sessions/#best-practices","text":"Development vs Production Development : Use MemorySession for simplicity and speed Production : Use SQLiteSession for data persistence Testing : Use MemorySession for isolated test cases Long-Running : Use SQLiteSession for multi-day conversations Session Management Unique IDs : Use meaningful session IDs (user ID, conversation ID) Lifecycle : Match session lifecycle to conversation lifecycle Cleanup : Periodically clear old or abandoned sessions Size Monitoring : Monitor database size for long conversations Isolation : One session per conversation/user for clean separation Performance Connection Reuse : Reuse SQLiteSession instances when possible Batch Operations : Add multiple items at once when applicable Index Strategy : SQLiteSession automatically indexes session_id WAL Mode : SQLiteSession uses WAL mode for better concurrency History Limits : Consider truncating very long conversation histories Common Mistakes Sharing Sessions : Don't share sessions across unrelated conversations Missing try-with-resources : Always close SQLiteSession (use try-with-resources) Lost Context : Forgetting to pass session via RunConfig Memory Leaks : Not cleaning up MemorySession references File Permissions : Ensure write permissions for SQLiteSession database path","title":"Best Practices"},{"location":"guides/sessions/#comparing-session-types","text":"Feature MemorySession SQLiteSession Persistence No (lost on exit) Yes (survives restarts) Performance Fast (in-memory) Good (disk I/O) Concurrency Thread-safe Thread-safe + WAL Storage Limit JVM memory Disk space Setup None required Database file Use Case Dev/testing Production Cleanup Automatic (GC) Manual Multi-session Separate instances Single database","title":"Comparing Session Types"},{"location":"guides/sessions/#next-steps","text":"Running Agents - Use RunConfig to pass sessions Handoffs - Maintain context across agent handoffs Run Context - Combine sessions with custom context Tools - Store tool interactions in sessions","title":"Next Steps"},{"location":"guides/sessions/#additional-resources","text":"MemorySessionExample.java - In-memory session usage SQLiteSessionExample.java - Persistent storage API Reference - Complete Javadoc documentation","title":"Additional Resources"},{"location":"guides/streaming/","text":"Streaming lets you consume run events as they happen. In this SDK, streaming emits run items as they are produced (message outputs, tool calls, tool outputs, and handoffs). Overview Streaming is event-based, not token-based. You receive structured events as the run progresses: Message outputs Tool calls and tool outputs Handoff calls and outputs Start a Streamed Run Use Runner.runStreamed() : StreamedRunResult < UnknownContext , Agent < UnknownContext , TextOutput >> result = Runner . runStreamed ( agent , \"Tell me a short story.\" ); ReadableStream < RunStreamEvent > stream = result . toStream (); ReadableStreamAsyncIterator < RunStreamEvent > it = stream . values (); while ( it . hasNext ()) { RunStreamEvent event = it . next (); System . out . println ( event . getType ()); } Text-Only Convenience Stream If you only care about message text, use toTextStream() : ReadableStream < String > textStream = result . toTextStream (); ReadableStreamAsyncIterator < String > it = textStream . values (); while ( it . hasNext ()) { String chunk = it . next (); System . out . print ( chunk ); } Emitted Event Types The stream currently emits RunItemStreamEvent for items produced during the run: message_output_created (assistant message output) tool_called tool_output handoff_called handoff_output Each event also includes the turnIndex and the underlying RunItem . Limitations The OpenAI provider does not implement model-level token streaming yet. OpenAIResponsesModel.getStreamedResponse() throws NotImplementedException . As a result, runStreamed() emits items after each model response is received (not token-by-token). Tips Use runStreamed() for UI updates or progress reporting during tool-heavy flows. Prefer toTextStream() if you only need assistant text.","title":"Streaming"},{"location":"guides/streaming/#overview","text":"Streaming is event-based, not token-based. You receive structured events as the run progresses: Message outputs Tool calls and tool outputs Handoff calls and outputs","title":"Overview"},{"location":"guides/streaming/#start-a-streamed-run","text":"Use Runner.runStreamed() : StreamedRunResult < UnknownContext , Agent < UnknownContext , TextOutput >> result = Runner . runStreamed ( agent , \"Tell me a short story.\" ); ReadableStream < RunStreamEvent > stream = result . toStream (); ReadableStreamAsyncIterator < RunStreamEvent > it = stream . values (); while ( it . hasNext ()) { RunStreamEvent event = it . next (); System . out . println ( event . getType ()); }","title":"Start a Streamed Run"},{"location":"guides/streaming/#text-only-convenience-stream","text":"If you only care about message text, use toTextStream() : ReadableStream < String > textStream = result . toTextStream (); ReadableStreamAsyncIterator < String > it = textStream . values (); while ( it . hasNext ()) { String chunk = it . next (); System . out . print ( chunk ); }","title":"Text-Only Convenience Stream"},{"location":"guides/streaming/#emitted-event-types","text":"The stream currently emits RunItemStreamEvent for items produced during the run: message_output_created (assistant message output) tool_called tool_output handoff_called handoff_output Each event also includes the turnIndex and the underlying RunItem .","title":"Emitted Event Types"},{"location":"guides/streaming/#limitations","text":"The OpenAI provider does not implement model-level token streaming yet. OpenAIResponsesModel.getStreamedResponse() throws NotImplementedException . As a result, runStreamed() emits items after each model response is received (not token-by-token).","title":"Limitations"},{"location":"guides/streaming/#tips","text":"Use runStreamed() for UI updates or progress reporting during tool-heavy flows. Prefer toTextStream() if you only need assistant text.","title":"Tips"},{"location":"guides/tools/","text":"Learn how to define custom tools that agents can invoke. Overview Tools allow agents to perform actions beyond text generation. Tools are Java functions that agents call autonomously to access data, perform calculations, or interact with external systems. The agent decides when to invoke tools based on the conversation context. OpenAI Function Calling This SDK implements OpenAI's function calling framework , which enables agents to autonomously invoke tools during conversations. OpenAI models decide when and how to call functions based on the conversation context and available tool definitions. Each tool is defined using the FunctionTool interface with: Type-safe input parameters Type-safe output values Automatic JSON schema generation Optional approval requirements Enable/disable logic Automatic validation at agent build time Required Annotations For OpenAI's function calling to work correctly, input parameter classes must have proper Jackson annotations: @Data @JsonTypeName ( \"calculator\" ) // Required: Identifies the tool parameter type @JsonClassDescription ( \"Input parameters for arithmetic operations\" ) // Required: Describes the parameters public static class Input { @JsonPropertyDescription ( \"The arithmetic operation to perform\" ) // Required: Describes each field private String operation ; @JsonPropertyDescription ( \"The first number\" ) private double a ; @JsonPropertyDescription ( \"The second number\" ) private double b ; } Validation at Build Time The SDK automatically validates tools when you build an agent. If your tool is missing required annotations, you'll get a clear error message pointing to the issue. This prevents runtime failures with the OpenAI API. All tools are automatically validated for: - @JsonTypeName or @JsonClassDescription on the Input class - @JsonPropertyDescription on all input fields - Valid getName(), getDescription(), and getParameters() implementations Creating a Simple Tool Implement FunctionTool with typed input and output classes: public class CalculatorTool implements FunctionTool < Object , CalculatorTool . Input , CalculatorTool . Output > { @Data @JsonClassDescription ( \"Input parameters for arithmetic operations\" ) public static class Input { @JsonPropertyDescription ( \"The arithmetic operation: add, subtract, multiply, or divide\" ) private String operation ; @JsonPropertyDescription ( \"The first number\" ) private double a ; @JsonPropertyDescription ( \"The second number\" ) private double b ; } @Data @AllArgsConstructor public static class Output { private double result ; private String operation ; private String expression ; } @Override public String getName () { return \"calculator\" ; } @Override public String getDescription () { return \"Performs basic arithmetic operations: add, subtract, multiply, divide.\" ; } @Override public Object getParameters () { return Input . class ; // Jackson auto-generates JSON schema } @Override public CompletableFuture < Output > invoke ( RunContext < Object > context , Input input ) { return CompletableFuture . supplyAsync (() -> { double result = switch ( input . getOperation ()) { case \"add\" -> input . getA () + input . getB (); case \"subtract\" -> input . getA () - input . getB (); case \"multiply\" -> input . getA () * input . getB (); case \"divide\" -> { if ( input . getB () == 0 ) throw new IllegalArgumentException ( \"Cannot divide by zero\" ); yield input . getA () / input . getB (); } default -> throw new IllegalArgumentException ( \"Unknown operation: \" + input . getOperation ()); }; String expression = String . format ( \"%.2f %s %.2f = %.2f\" , input . getA (), getOperatorSymbol ( input . getOperation ()), input . getB (), result ); return new Output ( result , input . getOperation (), expression ); }); } @Override public boolean needsApproval ( RunContext < Object > context , Input input ) { return false ; // Calculator doesn't need approval } @Override public boolean isEnabled ( RunContext < Object > context ) { return true ; // Always enabled } } View complete example \u2192 Adding Tools to an Agent Pass tools to the agent builder: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"MathAssistant\" ) . instructions ( \"You are a math assistant. Use the calculator tool to perform calculations.\" ) . tools ( List . of ( new CalculatorTool ())) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What is 123 multiplied by 456? Please use the calculator.\" ); System . out . println ( result . getFinalOutput ()); // Output: \"123 multiplied by 456 equals 56,088. I used the calculator to compute this: 123.00 \u00d7 456.00 = 56088.00\" The agent automatically calls the tool when needed and incorporates the result into its response. View complete example \u2192 Type-Safe Input Parameters Use Lombok @Data and Jackson annotations for clean, type-safe parameter definitions: @Data @JsonClassDescription ( \"Parameters for getting weather information\" ) public static class Input { @JsonPropertyDescription ( \"The city name (e.g., 'San Francisco', 'New York')\" ) private String city ; @JsonPropertyDescription ( \"Optional: Units for temperature (celsius or fahrenheit)\" ) private String units = \"fahrenheit\" ; // Default value @JsonPropertyDescription ( \"Optional: Include forecast for next N days (0-7)\" ) private int forecastDays = 0 ; } Benefits: Type Safety : Compile-time checking of all parameters Auto-complete : IDE support for parameter names and types Documentation : Annotations describe parameters for the model Schema Generation : Jackson automatically generates JSON schema Validation : Type system prevents invalid inputs View complex example with nested types \u2192 Type-Safe Output Values Define structured output using POJOs: @Data public static class Output { private String city ; private Current current ; private List < Forecast > forecast ; @Data public static class Current { private double temperature ; private String conditions ; private int humidity ; private String units ; } @Data @AllArgsConstructor public static class Forecast { private String date ; private double highTemp ; private double lowTemp ; private String conditions ; } } The agent receives the structured output and can reference specific fields in its response. FunctionTool Interface All tools implement the FunctionTool<TContext, TInput, TOutput> interface: public interface FunctionTool < TContext , TInput , TOutput > { // Required: Tool identification String getName (); String getDescription (); Object getParameters (); // Usually returns Input.class // Required: Tool execution CompletableFuture < TOutput > invoke ( RunContext < TContext > context , TInput input ); // Optional: Control flow boolean needsApproval ( RunContext < TContext > context , TInput input ); boolean isEnabled ( RunContext < TContext > context ); // Optional: Configuration String getType (); // Default: \"function\" boolean isStrict (); // Default: false } Type Parameters Parameter Description Example TContext Custom context type for approval/tracking Object , MyContext TInput Tool input parameter type CalculatorTool.Input TOutput Tool return value type CalculatorTool.Output JSON Schema Generation The SDK automatically generates JSON schemas from your input classes using Jackson annotations: @Data @JsonClassDescription ( \"Input parameters for arithmetic operations\" ) public static class Input { @JsonPropertyDescription ( \"The arithmetic operation to perform\" ) private String operation ; @JsonPropertyDescription ( \"The first number\" ) private double a ; @JsonPropertyDescription ( \"The second number\" ) private double b ; } Generated schema: { \"type\" : \"object\" , \"description\" : \"Input parameters for arithmetic operations\" , \"properties\" : { \"operation\" : { \"type\" : \"string\" , \"description\" : \"The arithmetic operation to perform\" }, \"a\" : { \"type\" : \"number\" , \"description\" : \"The first number\" }, \"b\" : { \"type\" : \"number\" , \"description\" : \"The second number\" } }, \"required\" : [ \"operation\" , \"a\" , \"b\" ] } The model uses this schema to generate valid tool calls. Tool Approval System Control tool execution with the needsApproval() method: @Override public boolean needsApproval ( RunContext < Object > context , Input input ) { // Require approval for delete operations return input . getOperation (). equals ( \"delete\" ); } When a tool needs approval: Execution pauses before invoking the tool Your context can implement approval logic The tool runs only if approved See the Run Context guide for implementing approval workflows. Example: Approval for Sensitive Operations public class FileOperationsTool implements FunctionTool < MyContext , Input , Output > { @Override public boolean needsApproval ( RunContext < MyContext > context , Input input ) { // Require approval for writes and deletes return input . getOperation (). equals ( \"write\" ) || input . getOperation (). equals ( \"delete\" ); } @Override public CompletableFuture < Output > invoke ( RunContext < MyContext > context , Input input ) { // Tool only runs if approved by context return CompletableFuture . supplyAsync (() -> { // Perform file operation return new Output ( /* ... */ ); }); } } Conditional Tool Enabling Control tool availability with isEnabled() : @Override public boolean isEnabled ( RunContext < MyContext > context ) { // Only enable if user has premium access return context . getContextData (). hasPremiumAccess (); } Disabled tools are not presented to the model as available functions. Example: Feature Flags public class AdvancedSearchTool implements FunctionTool < MyContext , Input , Output > { @Override public boolean isEnabled ( RunContext < MyContext > context ) { // Check feature flag return context . getContextData (). isFeatureEnabled ( \"advanced_search\" ); } } Multiple Tools Agents can use multiple tools simultaneously: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"GeneralAssistant\" ) . instructions ( \"Use available tools to answer questions accurately.\" ) . tools ( List . of ( new CalculatorTool (), new WeatherTool (), new SearchTool () )) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What's the weather in NYC? Also, what's 65\u00b0F in Celsius? Use (F - 32) * 5/9\" ); // Agent will call WeatherTool, then CalculatorTool to answer both questions The agent selects the appropriate tool(s) based on the task and available functions. Hosted Tools Hosted tools execute on OpenAI's infrastructure rather than in your application. These tools are provided and maintained by OpenAI, so you configure them but don't implement their logic. Currently Supported Hosted Tools This SDK currently supports: web_search - Search the web for current information image_generation - Generate images using DALL-E Limited Support Other OpenAI hosted tools like file_search , code_interpreter , and computer_use are not yet supported by this SDK. Attempting to use them will throw an UnsupportedOperationException . Web Search Example Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"SearchAssistant\" ) . instructions ( \"You can search the web for current information.\" ) . tools ( List . of ( HostedTool . webSearch ())) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What is the current weather in Tokyo?\" ); System . out . println ( result . getFinalOutput ()); Image Generation Example Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Artist\" ) . instructions ( \"You can generate images using DALL-E.\" ) . tools ( List . of ( HostedTool . imageGeneration ())) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Generate an image of a serene mountain landscape\" ); System . out . println ( result . getFinalOutput ()); Combining Hosted and Function Tools You can use hosted tools alongside your custom function tools: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"MultiToolAssistant\" ) . instructions ( \"Use available tools to answer questions.\" ) . tools ( List . of ( new CalculatorTool (), // Custom function tool HostedTool . webSearch (), // Hosted tool HostedTool . imageGeneration () // Hosted tool )) . build (); View complete example \u2192 Error Handling in Tools When a tool encounters an error (missing credentials, invalid input, external API failure), return the error information in the output structure. The agent will read the error and communicate it to the user appropriately. @Override public CompletableFuture < Output > invoke ( RunContext < Object > context , Input input ) { return CompletableFuture . completedFuture (() -> { // Check for missing configuration if ( apiKey == null ) { return new Output ( false , \"API credentials not configured. Please set up credentials.\" ); } try { // Perform operation Result result = performOperation ( input ); return new Output ( true , \"Operation completed successfully\" , result ); } catch ( Exception e ) { // Return error in output for the agent to communicate return new Output ( false , \"Error: \" + e . getMessage (), null ); } }); } public record Output ( @JsonProperty boolean success , @JsonProperty String message , @JsonProperty Result data ) {} Error Patterns See ErrorReturningTool in BadToolExampleTest.java for a complete example of proper error handling. The agent successfully reads error responses and communicates them to users. Throwing Exceptions If your tool throws an uncaught exception, the SDK catches it and converts it to an error message for the agent. However, it's better to handle errors gracefully and return structured error information in your Output type. Testing Tools with ToolValidator Use ToolValidator in your tests to ensure tools are properly configured before deploying: @Test void myTool_isProperlyConfigured () { ToolValidator . validate ( new MyTool ()); } The validator checks for: - Required Jackson annotations ( @JsonTypeName , @JsonClassDescription , @JsonPropertyDescription ) - Valid getName(), getDescription(), and getParameters() implementations - Proper parameter class structure If validation fails, you'll get a detailed error message: Tool 'my_tool' has validation errors : - Parameter class 'Input' should have @ JsonTypeName or @ JsonClassDescription annotation for proper OpenAI schema generation - Parameter class 'Input' has fields without @ JsonPropertyDescription annotations See ErrorReturningTool in BadToolExampleTest for a working example . Validate During Development Add ToolValidator.validate(new MyTool()) to your test suite to catch configuration issues early. This prevents runtime failures when the agent tries to use your tool. See ToolValidatorTest.java for comprehensive validation examples. Best Practices Tool Design Single Responsibility : Each tool should do one thing well Clear Naming : Use descriptive names like get_weather , not tool1 Rich Descriptions : Help the agent understand when to use the tool Validate Inputs : Check parameters before performing operations Meaningful Errors : Return clear error messages in the output Type Safety Use Lombok @Data to eliminate boilerplate Add Jackson @JsonPropertyDescription for all fields Use primitive types for required parameters Use wrapper types or defaults for optional parameters Leverage Java's type system for compile-time safety Performance Return CompletableFuture for async operations Use connection pools for database/API tools Cache frequently accessed data Set reasonable timeouts for external calls Log tool execution for monitoring Security Use needsApproval() for dangerous operations Validate and sanitize all inputs Use isEnabled() for access control Never expose sensitive data in error messages Log security-relevant tool calls Common Tool Patterns External API Tool public class WeatherTool implements FunctionTool < Object , Input , Output > { private final HttpClient httpClient = HttpClient . newHttpClient (); @Override public CompletableFuture < Output > invoke ( RunContext < Object > context , Input input ) { return httpClient . sendAsync ( buildRequest ( input ), HttpResponse . BodyHandlers . ofString ()) . thenApply ( this :: parseResponse ); } } Database Query Tool public class DatabaseTool implements FunctionTool < Object , Input , Output > { private final DataSource dataSource ; @Override public CompletableFuture < Output > invoke ( RunContext < Object > context , Input input ) { return CompletableFuture . supplyAsync (() -> { try ( Connection conn = dataSource . getConnection ()) { return executeQuery ( conn , input ); } }); } } File System Tool public class FileReadTool implements FunctionTool < MyContext , Input , Output > { @Override public boolean needsApproval ( RunContext < MyContext > context , Input input ) { // Require approval for files outside allowed directories return ! isAllowedPath ( input . getPath ()); } @Override public CompletableFuture < Output > invoke ( RunContext < MyContext > context , Input input ) { return CompletableFuture . supplyAsync (() -> { String content = Files . readString ( Path . of ( input . getPath ())); return new Output ( content ); }); } } Next Steps Run Context - Implement tool approval workflows Handoffs - Multi-agent systems with specialized tools Guardrails - Add safety constraints to tool usage Sessions - Maintain conversation context across tool calls Additional Resources WellTypedToolsExample.java - Multiple tool examples CalculatorTool.java - Simple tool WeatherTool.java - Complex nested types API Reference - Complete Javadoc documentation","title":"Tools"},{"location":"guides/tools/#overview","text":"Tools allow agents to perform actions beyond text generation. Tools are Java functions that agents call autonomously to access data, perform calculations, or interact with external systems. The agent decides when to invoke tools based on the conversation context. OpenAI Function Calling This SDK implements OpenAI's function calling framework , which enables agents to autonomously invoke tools during conversations. OpenAI models decide when and how to call functions based on the conversation context and available tool definitions. Each tool is defined using the FunctionTool interface with: Type-safe input parameters Type-safe output values Automatic JSON schema generation Optional approval requirements Enable/disable logic Automatic validation at agent build time","title":"Overview"},{"location":"guides/tools/#required-annotations","text":"For OpenAI's function calling to work correctly, input parameter classes must have proper Jackson annotations: @Data @JsonTypeName ( \"calculator\" ) // Required: Identifies the tool parameter type @JsonClassDescription ( \"Input parameters for arithmetic operations\" ) // Required: Describes the parameters public static class Input { @JsonPropertyDescription ( \"The arithmetic operation to perform\" ) // Required: Describes each field private String operation ; @JsonPropertyDescription ( \"The first number\" ) private double a ; @JsonPropertyDescription ( \"The second number\" ) private double b ; } Validation at Build Time The SDK automatically validates tools when you build an agent. If your tool is missing required annotations, you'll get a clear error message pointing to the issue. This prevents runtime failures with the OpenAI API. All tools are automatically validated for: - @JsonTypeName or @JsonClassDescription on the Input class - @JsonPropertyDescription on all input fields - Valid getName(), getDescription(), and getParameters() implementations","title":"Required Annotations"},{"location":"guides/tools/#creating-a-simple-tool","text":"Implement FunctionTool with typed input and output classes: public class CalculatorTool implements FunctionTool < Object , CalculatorTool . Input , CalculatorTool . Output > { @Data @JsonClassDescription ( \"Input parameters for arithmetic operations\" ) public static class Input { @JsonPropertyDescription ( \"The arithmetic operation: add, subtract, multiply, or divide\" ) private String operation ; @JsonPropertyDescription ( \"The first number\" ) private double a ; @JsonPropertyDescription ( \"The second number\" ) private double b ; } @Data @AllArgsConstructor public static class Output { private double result ; private String operation ; private String expression ; } @Override public String getName () { return \"calculator\" ; } @Override public String getDescription () { return \"Performs basic arithmetic operations: add, subtract, multiply, divide.\" ; } @Override public Object getParameters () { return Input . class ; // Jackson auto-generates JSON schema } @Override public CompletableFuture < Output > invoke ( RunContext < Object > context , Input input ) { return CompletableFuture . supplyAsync (() -> { double result = switch ( input . getOperation ()) { case \"add\" -> input . getA () + input . getB (); case \"subtract\" -> input . getA () - input . getB (); case \"multiply\" -> input . getA () * input . getB (); case \"divide\" -> { if ( input . getB () == 0 ) throw new IllegalArgumentException ( \"Cannot divide by zero\" ); yield input . getA () / input . getB (); } default -> throw new IllegalArgumentException ( \"Unknown operation: \" + input . getOperation ()); }; String expression = String . format ( \"%.2f %s %.2f = %.2f\" , input . getA (), getOperatorSymbol ( input . getOperation ()), input . getB (), result ); return new Output ( result , input . getOperation (), expression ); }); } @Override public boolean needsApproval ( RunContext < Object > context , Input input ) { return false ; // Calculator doesn't need approval } @Override public boolean isEnabled ( RunContext < Object > context ) { return true ; // Always enabled } } View complete example \u2192","title":"Creating a Simple Tool"},{"location":"guides/tools/#adding-tools-to-an-agent","text":"Pass tools to the agent builder: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"MathAssistant\" ) . instructions ( \"You are a math assistant. Use the calculator tool to perform calculations.\" ) . tools ( List . of ( new CalculatorTool ())) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What is 123 multiplied by 456? Please use the calculator.\" ); System . out . println ( result . getFinalOutput ()); // Output: \"123 multiplied by 456 equals 56,088. I used the calculator to compute this: 123.00 \u00d7 456.00 = 56088.00\" The agent automatically calls the tool when needed and incorporates the result into its response. View complete example \u2192","title":"Adding Tools to an Agent"},{"location":"guides/tools/#type-safe-input-parameters","text":"Use Lombok @Data and Jackson annotations for clean, type-safe parameter definitions: @Data @JsonClassDescription ( \"Parameters for getting weather information\" ) public static class Input { @JsonPropertyDescription ( \"The city name (e.g., 'San Francisco', 'New York')\" ) private String city ; @JsonPropertyDescription ( \"Optional: Units for temperature (celsius or fahrenheit)\" ) private String units = \"fahrenheit\" ; // Default value @JsonPropertyDescription ( \"Optional: Include forecast for next N days (0-7)\" ) private int forecastDays = 0 ; } Benefits: Type Safety : Compile-time checking of all parameters Auto-complete : IDE support for parameter names and types Documentation : Annotations describe parameters for the model Schema Generation : Jackson automatically generates JSON schema Validation : Type system prevents invalid inputs View complex example with nested types \u2192","title":"Type-Safe Input Parameters"},{"location":"guides/tools/#type-safe-output-values","text":"Define structured output using POJOs: @Data public static class Output { private String city ; private Current current ; private List < Forecast > forecast ; @Data public static class Current { private double temperature ; private String conditions ; private int humidity ; private String units ; } @Data @AllArgsConstructor public static class Forecast { private String date ; private double highTemp ; private double lowTemp ; private String conditions ; } } The agent receives the structured output and can reference specific fields in its response.","title":"Type-Safe Output Values"},{"location":"guides/tools/#functiontool-interface","text":"All tools implement the FunctionTool<TContext, TInput, TOutput> interface: public interface FunctionTool < TContext , TInput , TOutput > { // Required: Tool identification String getName (); String getDescription (); Object getParameters (); // Usually returns Input.class // Required: Tool execution CompletableFuture < TOutput > invoke ( RunContext < TContext > context , TInput input ); // Optional: Control flow boolean needsApproval ( RunContext < TContext > context , TInput input ); boolean isEnabled ( RunContext < TContext > context ); // Optional: Configuration String getType (); // Default: \"function\" boolean isStrict (); // Default: false }","title":"FunctionTool Interface"},{"location":"guides/tools/#type-parameters","text":"Parameter Description Example TContext Custom context type for approval/tracking Object , MyContext TInput Tool input parameter type CalculatorTool.Input TOutput Tool return value type CalculatorTool.Output","title":"Type Parameters"},{"location":"guides/tools/#json-schema-generation","text":"The SDK automatically generates JSON schemas from your input classes using Jackson annotations: @Data @JsonClassDescription ( \"Input parameters for arithmetic operations\" ) public static class Input { @JsonPropertyDescription ( \"The arithmetic operation to perform\" ) private String operation ; @JsonPropertyDescription ( \"The first number\" ) private double a ; @JsonPropertyDescription ( \"The second number\" ) private double b ; } Generated schema: { \"type\" : \"object\" , \"description\" : \"Input parameters for arithmetic operations\" , \"properties\" : { \"operation\" : { \"type\" : \"string\" , \"description\" : \"The arithmetic operation to perform\" }, \"a\" : { \"type\" : \"number\" , \"description\" : \"The first number\" }, \"b\" : { \"type\" : \"number\" , \"description\" : \"The second number\" } }, \"required\" : [ \"operation\" , \"a\" , \"b\" ] } The model uses this schema to generate valid tool calls.","title":"JSON Schema Generation"},{"location":"guides/tools/#tool-approval-system","text":"Control tool execution with the needsApproval() method: @Override public boolean needsApproval ( RunContext < Object > context , Input input ) { // Require approval for delete operations return input . getOperation (). equals ( \"delete\" ); } When a tool needs approval: Execution pauses before invoking the tool Your context can implement approval logic The tool runs only if approved See the Run Context guide for implementing approval workflows.","title":"Tool Approval System"},{"location":"guides/tools/#example-approval-for-sensitive-operations","text":"public class FileOperationsTool implements FunctionTool < MyContext , Input , Output > { @Override public boolean needsApproval ( RunContext < MyContext > context , Input input ) { // Require approval for writes and deletes return input . getOperation (). equals ( \"write\" ) || input . getOperation (). equals ( \"delete\" ); } @Override public CompletableFuture < Output > invoke ( RunContext < MyContext > context , Input input ) { // Tool only runs if approved by context return CompletableFuture . supplyAsync (() -> { // Perform file operation return new Output ( /* ... */ ); }); } }","title":"Example: Approval for Sensitive Operations"},{"location":"guides/tools/#conditional-tool-enabling","text":"Control tool availability with isEnabled() : @Override public boolean isEnabled ( RunContext < MyContext > context ) { // Only enable if user has premium access return context . getContextData (). hasPremiumAccess (); } Disabled tools are not presented to the model as available functions.","title":"Conditional Tool Enabling"},{"location":"guides/tools/#example-feature-flags","text":"public class AdvancedSearchTool implements FunctionTool < MyContext , Input , Output > { @Override public boolean isEnabled ( RunContext < MyContext > context ) { // Check feature flag return context . getContextData (). isFeatureEnabled ( \"advanced_search\" ); } }","title":"Example: Feature Flags"},{"location":"guides/tools/#multiple-tools","text":"Agents can use multiple tools simultaneously: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"GeneralAssistant\" ) . instructions ( \"Use available tools to answer questions accurately.\" ) . tools ( List . of ( new CalculatorTool (), new WeatherTool (), new SearchTool () )) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What's the weather in NYC? Also, what's 65\u00b0F in Celsius? Use (F - 32) * 5/9\" ); // Agent will call WeatherTool, then CalculatorTool to answer both questions The agent selects the appropriate tool(s) based on the task and available functions.","title":"Multiple Tools"},{"location":"guides/tools/#hosted-tools","text":"Hosted tools execute on OpenAI's infrastructure rather than in your application. These tools are provided and maintained by OpenAI, so you configure them but don't implement their logic.","title":"Hosted Tools"},{"location":"guides/tools/#currently-supported-hosted-tools","text":"This SDK currently supports: web_search - Search the web for current information image_generation - Generate images using DALL-E Limited Support Other OpenAI hosted tools like file_search , code_interpreter , and computer_use are not yet supported by this SDK. Attempting to use them will throw an UnsupportedOperationException .","title":"Currently Supported Hosted Tools"},{"location":"guides/tools/#web-search-example","text":"Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"SearchAssistant\" ) . instructions ( \"You can search the web for current information.\" ) . tools ( List . of ( HostedTool . webSearch ())) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"What is the current weather in Tokyo?\" ); System . out . println ( result . getFinalOutput ());","title":"Web Search Example"},{"location":"guides/tools/#image-generation-example","text":"Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"Artist\" ) . instructions ( \"You can generate images using DALL-E.\" ) . tools ( List . of ( HostedTool . imageGeneration ())) . build (); RunResult < UnknownContext , ?> result = Runner . run ( agent , \"Generate an image of a serene mountain landscape\" ); System . out . println ( result . getFinalOutput ());","title":"Image Generation Example"},{"location":"guides/tools/#combining-hosted-and-function-tools","text":"You can use hosted tools alongside your custom function tools: Agent < UnknownContext , TextOutput > agent = Agent . < UnknownContext , TextOutput > builder () . name ( \"MultiToolAssistant\" ) . instructions ( \"Use available tools to answer questions.\" ) . tools ( List . of ( new CalculatorTool (), // Custom function tool HostedTool . webSearch (), // Hosted tool HostedTool . imageGeneration () // Hosted tool )) . build (); View complete example \u2192","title":"Combining Hosted and Function Tools"},{"location":"guides/tools/#error-handling-in-tools","text":"When a tool encounters an error (missing credentials, invalid input, external API failure), return the error information in the output structure. The agent will read the error and communicate it to the user appropriately. @Override public CompletableFuture < Output > invoke ( RunContext < Object > context , Input input ) { return CompletableFuture . completedFuture (() -> { // Check for missing configuration if ( apiKey == null ) { return new Output ( false , \"API credentials not configured. Please set up credentials.\" ); } try { // Perform operation Result result = performOperation ( input ); return new Output ( true , \"Operation completed successfully\" , result ); } catch ( Exception e ) { // Return error in output for the agent to communicate return new Output ( false , \"Error: \" + e . getMessage (), null ); } }); } public record Output ( @JsonProperty boolean success , @JsonProperty String message , @JsonProperty Result data ) {} Error Patterns See ErrorReturningTool in BadToolExampleTest.java for a complete example of proper error handling. The agent successfully reads error responses and communicates them to users. Throwing Exceptions If your tool throws an uncaught exception, the SDK catches it and converts it to an error message for the agent. However, it's better to handle errors gracefully and return structured error information in your Output type.","title":"Error Handling in Tools"},{"location":"guides/tools/#testing-tools-with-toolvalidator","text":"Use ToolValidator in your tests to ensure tools are properly configured before deploying: @Test void myTool_isProperlyConfigured () { ToolValidator . validate ( new MyTool ()); } The validator checks for: - Required Jackson annotations ( @JsonTypeName , @JsonClassDescription , @JsonPropertyDescription ) - Valid getName(), getDescription(), and getParameters() implementations - Proper parameter class structure If validation fails, you'll get a detailed error message: Tool 'my_tool' has validation errors : - Parameter class 'Input' should have @ JsonTypeName or @ JsonClassDescription annotation for proper OpenAI schema generation - Parameter class 'Input' has fields without @ JsonPropertyDescription annotations See ErrorReturningTool in BadToolExampleTest for a working example . Validate During Development Add ToolValidator.validate(new MyTool()) to your test suite to catch configuration issues early. This prevents runtime failures when the agent tries to use your tool. See ToolValidatorTest.java for comprehensive validation examples.","title":"Testing Tools with ToolValidator"},{"location":"guides/tools/#best-practices","text":"Tool Design Single Responsibility : Each tool should do one thing well Clear Naming : Use descriptive names like get_weather , not tool1 Rich Descriptions : Help the agent understand when to use the tool Validate Inputs : Check parameters before performing operations Meaningful Errors : Return clear error messages in the output Type Safety Use Lombok @Data to eliminate boilerplate Add Jackson @JsonPropertyDescription for all fields Use primitive types for required parameters Use wrapper types or defaults for optional parameters Leverage Java's type system for compile-time safety Performance Return CompletableFuture for async operations Use connection pools for database/API tools Cache frequently accessed data Set reasonable timeouts for external calls Log tool execution for monitoring Security Use needsApproval() for dangerous operations Validate and sanitize all inputs Use isEnabled() for access control Never expose sensitive data in error messages Log security-relevant tool calls","title":"Best Practices"},{"location":"guides/tools/#common-tool-patterns","text":"","title":"Common Tool Patterns"},{"location":"guides/tools/#external-api-tool","text":"public class WeatherTool implements FunctionTool < Object , Input , Output > { private final HttpClient httpClient = HttpClient . newHttpClient (); @Override public CompletableFuture < Output > invoke ( RunContext < Object > context , Input input ) { return httpClient . sendAsync ( buildRequest ( input ), HttpResponse . BodyHandlers . ofString ()) . thenApply ( this :: parseResponse ); } }","title":"External API Tool"},{"location":"guides/tools/#database-query-tool","text":"public class DatabaseTool implements FunctionTool < Object , Input , Output > { private final DataSource dataSource ; @Override public CompletableFuture < Output > invoke ( RunContext < Object > context , Input input ) { return CompletableFuture . supplyAsync (() -> { try ( Connection conn = dataSource . getConnection ()) { return executeQuery ( conn , input ); } }); } }","title":"Database Query Tool"},{"location":"guides/tools/#file-system-tool","text":"public class FileReadTool implements FunctionTool < MyContext , Input , Output > { @Override public boolean needsApproval ( RunContext < MyContext > context , Input input ) { // Require approval for files outside allowed directories return ! isAllowedPath ( input . getPath ()); } @Override public CompletableFuture < Output > invoke ( RunContext < MyContext > context , Input input ) { return CompletableFuture . supplyAsync (() -> { String content = Files . readString ( Path . of ( input . getPath ())); return new Output ( content ); }); } }","title":"File System Tool"},{"location":"guides/tools/#next-steps","text":"Run Context - Implement tool approval workflows Handoffs - Multi-agent systems with specialized tools Guardrails - Add safety constraints to tool usage Sessions - Maintain conversation context across tool calls","title":"Next Steps"},{"location":"guides/tools/#additional-resources","text":"WellTypedToolsExample.java - Multiple tool examples CalculatorTool.java - Simple tool WeatherTool.java - Complex nested types API Reference - Complete Javadoc documentation","title":"Additional Resources"},{"location":"guides/tracing/","text":"Tracing captures workflows and spans for observability. The tracing system is available today, but it is not auto-wired into the Runner yet, so you create traces and spans explicitly. Overview Tracing is built from: TraceProvider for global configuration and processor registration TraceContext for context propagation Trace and Span for the actual trace data Processors/exporters for output (console or OpenAI) Quick Start (Console Tracing) TraceProcessor processor = new ConsoleTraceProcessor ( true ); TraceProvider provider = TraceProvider . getGlobalTraceProvider (); provider . registerProcessor ( processor ); Trace trace = provider . createTrace ( Trace . builder () . traceId ( TracingUtils . generateTraceId ()) . name ( \"Example workflow\" ) . build ()); TraceContext . withTrace ( trace , () -> { Span < CustomSpanData > span = provider . createSpan ( Span . < CustomSpanData > builder () . spanId ( TracingUtils . generateSpanId ()) . data ( CustomSpanData . builder (). name ( \"custom-op\" ). build ()) . build ()); span . start (); try { // Do work return null ; } finally { span . end (); } }); Export to OpenAI Tracing The SDK includes an OpenAI exporter and a batch processor: TraceProvider . initializeWithDefaultCloudTracing (); This configures: OpenAITraceExporter (uses OPENAI_API_KEY ) BatchTraceProcessor (batching and retries) Disabling Tracing Tracing can be disabled globally: Environment variable: OPENAI_AGENTS_DISABLE_TRACING=1 or true Runtime: TraceProvider.getGlobalTraceProvider().setDisabled(true) When disabled, NoopTrace and NoopSpan are returned with near-zero overhead. Context Propagation Tracing uses ThreadLocal . For async code, use helpers to preserve context: Trace trace = Trace . builder (). traceId ( TracingUtils . generateTraceId ()). name ( \"async\" ). build (); TraceContext . withTrace ( trace , () -> TraceContext . supplyAsync ( () -> { // Trace context is preserved here return \"ok\" ; })); Processor Options Built-in processors and exporters: ConsoleTraceProcessor : prints trace/span JSON to stdout (good for local dev). OpenAITraceExporter : HTTP export to OpenAI tracing endpoint. BatchTraceProcessor : buffers and sends traces/spans in batches. You can also register multiple processors with the global provider. Examples TracingExample.java - end-to-end trace and span creation (console only). AgentWithTracingExample.java - manual tracing around an agent run.","title":"Tracing"},{"location":"guides/tracing/#overview","text":"Tracing is built from: TraceProvider for global configuration and processor registration TraceContext for context propagation Trace and Span for the actual trace data Processors/exporters for output (console or OpenAI)","title":"Overview"},{"location":"guides/tracing/#quick-start-console-tracing","text":"TraceProcessor processor = new ConsoleTraceProcessor ( true ); TraceProvider provider = TraceProvider . getGlobalTraceProvider (); provider . registerProcessor ( processor ); Trace trace = provider . createTrace ( Trace . builder () . traceId ( TracingUtils . generateTraceId ()) . name ( \"Example workflow\" ) . build ()); TraceContext . withTrace ( trace , () -> { Span < CustomSpanData > span = provider . createSpan ( Span . < CustomSpanData > builder () . spanId ( TracingUtils . generateSpanId ()) . data ( CustomSpanData . builder (). name ( \"custom-op\" ). build ()) . build ()); span . start (); try { // Do work return null ; } finally { span . end (); } });","title":"Quick Start (Console Tracing)"},{"location":"guides/tracing/#export-to-openai-tracing","text":"The SDK includes an OpenAI exporter and a batch processor: TraceProvider . initializeWithDefaultCloudTracing (); This configures: OpenAITraceExporter (uses OPENAI_API_KEY ) BatchTraceProcessor (batching and retries)","title":"Export to OpenAI Tracing"},{"location":"guides/tracing/#disabling-tracing","text":"Tracing can be disabled globally: Environment variable: OPENAI_AGENTS_DISABLE_TRACING=1 or true Runtime: TraceProvider.getGlobalTraceProvider().setDisabled(true) When disabled, NoopTrace and NoopSpan are returned with near-zero overhead.","title":"Disabling Tracing"},{"location":"guides/tracing/#context-propagation","text":"Tracing uses ThreadLocal . For async code, use helpers to preserve context: Trace trace = Trace . builder (). traceId ( TracingUtils . generateTraceId ()). name ( \"async\" ). build (); TraceContext . withTrace ( trace , () -> TraceContext . supplyAsync ( () -> { // Trace context is preserved here return \"ok\" ; }));","title":"Context Propagation"},{"location":"guides/tracing/#processor-options","text":"Built-in processors and exporters: ConsoleTraceProcessor : prints trace/span JSON to stdout (good for local dev). OpenAITraceExporter : HTTP export to OpenAI tracing endpoint. BatchTraceProcessor : buffers and sends traces/spans in batches. You can also register multiple processors with the global provider.","title":"Processor Options"},{"location":"guides/tracing/#examples","text":"TracingExample.java - end-to-end trace and span creation (console only). AgentWithTracingExample.java - manual tracing around an agent run.","title":"Examples"},{"location":"guides/troubleshooting/","text":"Common issues and quick fixes when running the SDK locally. API Key Not Found If you see an error about a missing API key, export it before running examples: export OPENAI_API_KEY = \"your-api-key-here\" Java Version Mismatch This SDK requires Java 21+: java -version If you're on an older version, update your JDK and ensure JAVA_HOME points to it. Model Not Available If a model name is rejected, confirm it is available for your account and matches the provider: Prefer documented model IDs from OpenAI. If you configured a custom model provider, verify its naming rules. Build or Example Failures If examples fail to compile or run: mvn clean install If you only want unit tests: mvn test Still Stuck? Open an issue on GitHub: https://github.com/bnbarak/openai-agent-sdk/issues Include the command you ran and the full error output.","title":"Troubleshooting"},{"location":"guides/troubleshooting/#api-key-not-found","text":"If you see an error about a missing API key, export it before running examples: export OPENAI_API_KEY = \"your-api-key-here\"","title":"API Key Not Found"},{"location":"guides/troubleshooting/#java-version-mismatch","text":"This SDK requires Java 21+: java -version If you're on an older version, update your JDK and ensure JAVA_HOME points to it.","title":"Java Version Mismatch"},{"location":"guides/troubleshooting/#model-not-available","text":"If a model name is rejected, confirm it is available for your account and matches the provider: Prefer documented model IDs from OpenAI. If you configured a custom model provider, verify its naming rules.","title":"Model Not Available"},{"location":"guides/troubleshooting/#build-or-example-failures","text":"If examples fail to compile or run: mvn clean install If you only want unit tests: mvn test","title":"Build or Example Failures"},{"location":"guides/troubleshooting/#still-stuck","text":"Open an issue on GitHub: https://github.com/bnbarak/openai-agent-sdk/issues Include the command you ran and the full error output.","title":"Still Stuck?"}]}